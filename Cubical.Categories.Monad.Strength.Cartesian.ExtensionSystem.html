<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">{-
   Strong monads on cartesian categories as extension systems,
   i.e., in terms of unit and bind, deriving the rest of the structure
   https://ncatlab.org/nlab/show/extension+system
-}</a>
<a id="191" class="Symbol">{-#</a> <a id="195" class="Keyword">OPTIONS</a> <a id="203" class="Pragma">--safe</a> <a id="210" class="Pragma">--lossy-unification</a> <a id="230" class="Symbol">#-}</a>
<a id="234" class="Keyword">module</a> <a id="241" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html" class="Module">Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem</a> <a id="301" class="Keyword">where</a>

<a id="308" class="Keyword">open</a> <a id="313" class="Keyword">import</a> <a id="320" href="Cubical.Foundations.Prelude.html" class="Module">Cubical.Foundations.Prelude</a>

<a id="349" class="Keyword">open</a> <a id="354" class="Keyword">import</a> <a id="361" href="Cubical.Categories.Category.html" class="Module">Cubical.Categories.Category</a>
<a id="389" class="Keyword">open</a> <a id="394" class="Keyword">import</a> <a id="401" href="Cubical.Categories.Functor.html" class="Module">Cubical.Categories.Functor</a> <a id="428" class="Keyword">renaming</a> <a id="437" class="Symbol">(</a><a id="438" href="Cubical.Categories.Functor.Base.html#4002" class="Function Operator">ğŸ™âŸ¨_âŸ©</a> <a id="443" class="Symbol">to</a> <a id="446" class="Function Operator">funcId</a><a id="452" class="Symbol">)</a>
<a id="454" class="Keyword">open</a> <a id="459" class="Keyword">import</a> <a id="466" href="Cubical.Categories.Limits.BinProduct.More.html" class="Module">Cubical.Categories.Limits.BinProduct.More</a>
<a id="508" class="Keyword">open</a> <a id="513" class="Keyword">import</a> <a id="520" href="Cubical.Categories.Limits.Terminal.html" class="Module">Cubical.Categories.Limits.Terminal</a>
<a id="555" class="Keyword">open</a> <a id="560" class="Keyword">import</a> <a id="567" href="Cubical.Categories.Limits.Terminal.More.html" class="Module">Cubical.Categories.Limits.Terminal.More</a>
<a id="607" class="Keyword">open</a> <a id="612" class="Keyword">import</a> <a id="619" href="Cubical.Categories.Limits.Cartesian.Base.html" class="Module">Cubical.Categories.Limits.Cartesian.Base</a>
<a id="660" class="Keyword">open</a> <a id="665" class="Keyword">import</a> <a id="672" href="Cubical.Categories.Comonad.Instances.Environment.html" class="Module">Cubical.Categories.Comonad.Instances.Environment</a>
<a id="721" class="Keyword">open</a> <a id="726" class="Keyword">import</a> <a id="733" href="Cubical.Categories.Monad.ExtensionSystem.html" class="Module">Cubical.Categories.Monad.ExtensionSystem</a> <a id="774" class="Symbol">as</a> <a id="777" class="Module">Monad</a>

<a id="784" class="Keyword">open</a> <a id="789" class="Keyword">import</a> <a id="796" href="Cubical.Tactics.CategorySolver.Reflection.html" class="Module">Cubical.Tactics.CategorySolver.Reflection</a>

<a id="839" class="Keyword">private</a>
  <a id="849" class="Keyword">variable</a>
    <a id="862" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#862" class="Generalizable">â„“</a> <a id="864" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#864" class="Generalizable">â„“&#39;</a> <a id="867" class="Symbol">:</a> <a id="869" href="Agda.Primitive.html#742" class="Postulate">Level</a>

<a id="876" class="Keyword">module</a> <a id="883" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#883" class="Module">_</a> <a id="885" class="Symbol">{</a><a id="886" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#886" class="Bound">C</a> <a id="888" class="Symbol">:</a> <a id="890" href="Cubical.Categories.Category.Base.html#311" class="Record">Category</a> <a id="899" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#862" class="Generalizable">â„“</a> <a id="901" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#864" class="Generalizable">â„“&#39;</a><a id="903" class="Symbol">}</a> <a id="905" class="Symbol">(</a><a id="906" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#906" class="Bound">bp</a> <a id="909" class="Symbol">:</a> <a id="911" href="Cubical.Categories.Limits.BinProduct.More.html#1445" class="Function">BinProducts</a> <a id="923" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#886" class="Bound">C</a><a id="924" class="Symbol">)</a> <a id="926" class="Keyword">where</a>
  <a id="934" class="Keyword">open</a> <a id="939" href="Cubical.Categories.Category.Base.html#311" class="Module">Category</a>
  <a id="950" class="Keyword">open</a> <a id="955" href="Cubical.Categories.Limits.BinProduct.More.html#3354" class="Module">BinProductsNotation</a> <a id="975" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#906" class="Bound">bp</a>
  <a id="980" class="Comment">-- open EnvNotation bp</a>

  <a id="1006" class="Keyword">private</a>
    <a id="1018" class="Keyword">variable</a>
      <a id="1033" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#1033" class="Generalizable">Î“</a> <a id="1035" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#1035" class="Generalizable">Î”</a> <a id="1037" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#1037" class="Generalizable">a</a> <a id="1039" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#1039" class="Generalizable">b</a> <a id="1041" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#1041" class="Generalizable">c</a> <a id="1043" class="Symbol">:</a> <a id="1045" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#886" class="Bound">C</a> <a id="1047" class="Symbol">.</a><a id="1048" href="Cubical.Categories.Category.Base.html#429" class="Field">ob</a>
      <a id="1057" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#1057" class="Generalizable">Î³</a> <a id="1059" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#1059" class="Generalizable">Î´</a> <a id="1061" class="Symbol">:</a> <a id="1063" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#886" class="Bound">C</a> <a id="1065" href="Cubical.Categories.Category.Base.html#1210" class="Function Operator">[</a> <a id="1067" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#1035" class="Generalizable">Î”</a> <a id="1069" href="Cubical.Categories.Category.Base.html#1210" class="Function Operator">,</a> <a id="1071" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#1033" class="Generalizable">Î“</a> <a id="1073" href="Cubical.Categories.Category.Base.html#1210" class="Function Operator">]</a>
      <a id="1081" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#1081" class="Generalizable">f</a> <a id="1083" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#1083" class="Generalizable">g</a> <a id="1085" class="Symbol">:</a> <a id="1087" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#886" class="Bound">C</a> <a id="1089" href="Cubical.Categories.Category.Base.html#1210" class="Function Operator">[</a> <a id="1091" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#1037" class="Generalizable">a</a> <a id="1093" href="Cubical.Categories.Category.Base.html#1210" class="Function Operator">,</a> <a id="1095" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#1039" class="Generalizable">b</a> <a id="1097" href="Cubical.Categories.Category.Base.html#1210" class="Function Operator">]</a>
      <a id="1105" class="Comment">-- s t : With Î“ [ a , b ]</a>

  <a id="1134" class="Comment">-- TODO: reformulate this stuff in terms of Displayed categories.</a>
  <a id="1202" class="Comment">--</a>
  <a id="1207" class="Comment">-- This is what Jacobs calls the &quot;simple fibration&quot;</a>

<a id="1260" class="Comment">--   -- Env [ Î³ ][ a , b ] is a map Î” Ã— a â†’ b</a>

<a id="1307" class="Comment">--   -- With is a fibered category over C. With : C â†’ Cat</a>
<a id="1365" class="Comment">--   -- A Strong extension system is a section of this bundle of categories</a>
<a id="1441" class="Comment">--   open ExtensionSystemFor</a>
<a id="1470" class="Comment">--   record StrongExtensionSystem : Type (â„“-max â„“ â„“&#39;) where</a>
<a id="1530" class="Comment">--     field</a>
<a id="1543" class="Comment">--       T : C .ob â†’ C .ob</a>
<a id="1570" class="Comment">--       systems : âˆ€ Î“ â†’ Monad.ExtensionSystemFor (With Î“) T</a>
<a id="1631" class="Comment">--       -- Î· âˆ˜ (Î³ Ã— id) â‰¡ Î·</a>
<a id="1660" class="Comment">--       Î·-natural : (Î³ ^*) âŸª systems Î“ .Î· {a = a} âŸ« â‰¡ systems Î” .Î·</a>
<a id="1728" class="Comment">--       -- bind f âˆ˜ (Î³ Ã— id) â‰¡ bind (f âˆ˜ (Î³ Ã— id))</a>
<a id="1780" class="Comment">--       bind-natural :</a>
<a id="1804" class="Comment">--         (Î³ ^*) âŸª systems Î“ .bind s âŸ« â‰¡ systems Î” .bind ((Î³ ^*) âŸª s âŸ«)</a>
<a id="1877" class="Comment">--   -- | TODO: resulting Î·, bind are natural in all arguments</a>
<a id="1940" class="Comment">--   -- If C further has a terminal object we get an &quot;underlying monad&quot;</a>
<a id="2012" class="Comment">--   -- on C because Envs ğŸ™ â‰… Id</a>
<a id="2045" class="Comment">--   module _ (term : Terminal C) (SE : StrongExtensionSystem) where</a>
<a id="2114" class="Comment">--     open StrongExtensionSystem SE</a>
<a id="2151" class="Comment">--     open TerminalNotation C term</a>
<a id="2187" class="Comment">--     open CartesianCategoryNotation (C , term , bp)</a>
<a id="2241" class="Comment">--     open isIso</a>
<a id="2259" class="Comment">--     -- This follows abstractly from showing (ğŸ™ Ã—-) is equivalent to</a>
<a id="2330" class="Comment">--     -- the identity monad</a>
<a id="2359" class="Comment">--     -- we&#39;ll just be explicit here</a>

<a id="2398" class="Comment">--     E1 = systems ğŸ™</a>
<a id="2420" class="Comment">--     -- f âˆ˜ Ï€â‚‚</a>
<a id="2437" class="Comment">--     toWith1 : C [ a , b ] â†’ With ğŸ™ [ a , b ]</a>
<a id="2485" class="Comment">--     toWith1 = C ._â‹†_ (unitor-l .fst)</a>

<a id="2526" class="Comment">--     -- f âˆ˜ (! , id)</a>
<a id="2549" class="Comment">--     fromWith1 : With ğŸ™ [ a , b ] â†’ C [ a , b ]</a>
<a id="2599" class="Comment">--     fromWith1 = C ._â‹†_ (unitor-l .snd .inv)</a>

<a id="2647" class="Comment">--     fromTo : fromWith1 (toWith1 f) â‰¡ f</a>
<a id="2689" class="Comment">--     fromTo =</a>
<a id="2705" class="Comment">--       sym (C .â‹†Assoc _ _ _) âˆ™</a>
<a id="2738" class="Comment">--       congâ‚‚ (comp&#39; C) refl (unitor-l .snd .sec) âˆ™ C .â‹†IdL _</a>

<a id="2802" class="Comment">--     toFrom : toWith1 (fromWith1 f) â‰¡ f</a>
<a id="2844" class="Comment">--     toFrom =</a>
<a id="2860" class="Comment">--       sym (C .â‹†Assoc _ _ _) âˆ™</a>
<a id="2893" class="Comment">--       congâ‚‚ (comp&#39; C) refl (unitor-l .snd .ret) âˆ™ C .â‹†IdL _</a>

<a id="2957" class="Comment">--     -- TODO: recover a monad on the original category</a>
<a id="3014" class="Comment">--     -- General principle would be that you can transport a monad</a>
<a id="3082" class="Comment">--     -- along an equivalence of categories...</a>
<a id="3130" class="Comment">--     global-ESF : Monad.ExtensionSystemFor C T</a>
<a id="3179" class="Comment">--     global-ESF .Î· = fromWith1 (E1 .Î·)</a>
<a id="3220" class="Comment">--     global-ESF .bind s = fromWith1 (E1 .bind (toWith1 s))</a>
<a id="3281" class="Comment">--     global-ESF .bind-r =</a>
<a id="3309" class="Comment">--       cong fromWith1 (cong (E1 .bind) toFrom) âˆ™</a>
<a id="3360" class="Comment">--       cong fromWith1 (E1 .bind-r) âˆ™ Ã—Î²â‚‚</a>
<a id="3403" class="Comment">--     global-ESF .bind-l {f = f} =</a>
<a id="3439" class="Comment">--       -- (f o Ï€â‚‚)^+ âˆ˜ (!,id) âˆ˜ Î· âˆ˜ (!, id)</a>
<a id="3485" class="Comment">--       -- (f o Ï€â‚‚)^+ âˆ˜ (!,Î·) âˆ˜ Î· âˆ˜ (!, id)</a>
<a id="3530" class="Comment">--       ((C .â‹†Assoc _ _ _) âˆ™ congâ‚‚ (seq&#39; C) refl</a>
<a id="3580" class="Comment">--         (sym (C .â‹†Assoc _ _ _) âˆ™</a>
<a id="3616" class="Comment">--         congâ‚‚ (seq&#39; C)</a>
<a id="3642" class="Comment">--               (,p-natural âˆ™ congâ‚‚ _,p_ (ğŸ™Î·&#39; {g = Ï€â‚}) (C .â‹†IdR _)) refl âˆ™</a>
<a id="3719" class="Comment">--               E1 .bind-l {f = (toWith1 f)} ))</a>
<a id="3768" class="Comment">--       âˆ™ sym (C .â‹†Assoc _ _ _) âˆ™ congâ‚‚ (comp&#39; C) refl Ã—Î²â‚‚ âˆ™ C .â‹†IdL _</a>
<a id="3840" class="Comment">--     -- ((f âˆ˜ Ï€â‚‚)^+ âˆ˜ (! , id)) âˆ˜ ((g âˆ˜ Ï€â‚‚)^+ âˆ˜ (! , id))</a>
<a id="3900" class="Comment">--     global-ESF .bind-comp {f = f}{g = g} =</a>
<a id="3946" class="Comment">--     -- ((f âˆ˜ Ï€â‚‚)^+ âˆ˜ (! , id)) âˆ˜ ((g âˆ˜ Ï€â‚‚)^+ âˆ˜ (! , id))</a>
<a id="4006" class="Comment">--       lem -- f âˆ˜ğŸ™ g = f^+</a>
<a id="4035" class="Comment">--     -- ((f âˆ˜ Ï€â‚‚)^+ âˆ˜ (Ï€â‚ , (g âˆ˜ Ï€â‚‚)^+)) âˆ˜ (! , id)</a>
<a id="4089" class="Comment">--       âˆ™ congâ‚‚ (seq&#39; C) refl (congâ‚‚ (comp&#39; C) refl</a>
<a id="4142" class="Comment">--         (,p-natural âˆ™ congâ‚‚ _,p_ (ğŸ™Î·&#39; {g = Ï€â‚}) (C .â‹†IdR _)) âˆ™ E1 .bind-comp)</a>
<a id="4223" class="Comment">--       âˆ™ congâ‚‚ (seq&#39; C) refl (cong (E1 .bind)</a>
<a id="4271" class="Comment">--               -- (E1 .bind (toWith1 f)) âˆ˜ (Ï€â‚ , (g âˆ˜ Ï€â‚‚))</a>
<a id="4332" class="Comment">--               -- â‰¡ (E1 .bind (toWith f) âˆ˜ g âˆ˜ Ï€â‚‚)</a>
<a id="4385" class="Comment">--               ((congâ‚‚ (comp&#39; C) refl (congâ‚‚ _,p_ ğŸ™Î·&#39; (sym (C .â‹†IdR _)) âˆ™</a>
<a id="4461" class="Comment">--               sym ,p-natural) âˆ™ C .â‹†Assoc _ _ _) âˆ™ C .â‹†Assoc _ _ _))</a>
<a id="4533" class="Comment">--     -- (((f âˆ˜ Ï€â‚‚)^+ âˆ˜ (! , id) âˆ˜ g) âˆ˜ Ï€â‚‚)^+ âˆ˜ (! , id)</a>
<a id="4591" class="Comment">--       where</a>
<a id="4606" class="Comment">--         lem : comp&#39; C (fromWith1 (E1 .bind (toWith1 f)))</a>
<a id="4666" class="Comment">--               (fromWith1 (E1 .bind (toWith1 g))) â‰¡</a>
<a id="4720" class="Comment">--               ((E1 .bind (toWith1 f)) âˆ˜âŸ¨ C âŸ©</a>
<a id="4768" class="Comment">--                 ((!t ,p C .id) âˆ˜âŸ¨ C âŸ© E1 .bind (toWith1 g))) âˆ˜âŸ¨ C âŸ©</a>
<a id="4839" class="Comment">--                   ((!t ,p C .id))</a>
<a id="4876" class="Comment">--         lem = solveCat! C</a>
<a id="4905" class="Comment">--     StrongMonadâ†’Monad : Monad.ExtensionSystem C</a>
<a id="4956" class="Comment">--     StrongMonadâ†’Monad = T , global-ESF</a>

<a id="4999" class="Comment">--     -- TODO: once we establish that T is a functor,</a>
<a id="5054" class="Comment">--     -- we can show the following is natural</a>
<a id="5101" class="Comment">--     Ïƒ : C [ Î“ Ã— T a , T (Î“ Ã— a) ]</a>
<a id="5138" class="Comment">--     Ïƒ {Î“ = Î“} = systems Î“ .bind (fromWith1 (E1 .Î·))</a>
<a id="5193" class="Comment">-- module StrongMonadNotation {C : Category â„“ â„“&#39;}</a>
<a id="5243" class="Comment">--   (bp : BinProducts C) (SE : StrongExtensionSystem bp) where</a>
<a id="5307" class="Comment">--   open Category</a>
<a id="5326" class="Comment">--   open Notation C bp</a>
<a id="5350" class="Comment">--   open EnvNotation bp</a>
<a id="5375" class="Comment">--   open StrongExtensionSystem SE public</a>
<a id="5417" class="Comment">--   private</a>
<a id="5430" class="Comment">--     variable</a>
<a id="5446" class="Comment">--       Î“ Î” a b c : C .ob</a>
<a id="5473" class="Comment">--       Î³ Î´ : C [ Î” , Î“ ]</a>
<a id="5500" class="Comment">--       f g : C [ a , b ]</a>
<a id="5527" class="Comment">--       s t : With Î“ [ a , b ]</a>

<a id="5560" class="Comment">--   open Functor</a>

<a id="5579" class="Comment">--   PKleisli : C .ob â†’ Category _ _</a>
<a id="5616" class="Comment">--   PKleisli Î“ = Monad.Kleisli (With Î“) (T , systems Î“)</a>

<a id="5674" class="Comment">--   PG : (Î“ : C .ob) â†’ Functor (PKleisli Î“) (With Î“)</a>
<a id="5728" class="Comment">--   PG Î“ = Monad.G ((With Î“)) ((T , systems Î“))</a>

<a id="5778" class="Comment">--   bindP : PKleisli Î“ [ a , b ] â†’ With Î“ [ T a , T b ]</a>
<a id="5835" class="Comment">--   bindP {Î“ = Î“} = PG Î“ .F-hom</a>

<a id="5869" class="Comment">--   retP : PKleisli Î“ [ a , a ]</a>
<a id="5902" class="Comment">--   retP {Î“} = PKleisli Î“ .id</a>

<a id="5934" class="Comment">--   bindP-comp : bindP f âˆ˜âŸ¨ With Î“ âŸ© bindP g â‰¡ bindP (bindP f âˆ˜âŸ¨ With Î“ âŸ© g)</a>
<a id="6012" class="Comment">--   bindP-comp {Î“ = Î“} = ExtensionSystemFor.bind-comp (systems Î“)</a>

<a id="6080" class="Comment">--   bindP-l : bindP f âˆ˜âŸ¨ With Î“ âŸ© retP â‰¡ f</a>
<a id="6124" class="Comment">--   bindP-l {Î“ = Î“} = ExtensionSystemFor.bind-l (systems Î“)</a>

<a id="6186" class="Comment">--   bindP-r : bindP (retP {a = a}) â‰¡ With Î“ .id</a>
<a id="6235" class="Comment">--   bindP-r {Î“ = Î“} = ExtensionSystemFor.bind-r (systems Î“)</a>

<a id="6297" class="Comment">--   open Functor</a>

<a id="6316" class="Comment">--   pull : (Î³ : C [ Î” , Î“ ]) â†’ Functor (PKleisli Î“) (PKleisli Î”)</a>
<a id="6382" class="Comment">--   pull Î³ .F-ob = Î» z â†’ z</a>
<a id="6410" class="Comment">--   pull Î³ .F-hom f = (Î³ ^*) âŸª f âŸ«</a>
<a id="6446" class="Comment">--   pull Î³ .F-id = Î·-natural</a>
<a id="6476" class="Comment">--   pull {Î” = Î”} Î³ .F-seq f g =</a>
<a id="6509" class="Comment">--     (Î³ ^*) .F-seq _ _ âˆ™ congâ‚‚ (seq&#39; (With Î”)) refl bind-natural</a>
</pre></body></html>