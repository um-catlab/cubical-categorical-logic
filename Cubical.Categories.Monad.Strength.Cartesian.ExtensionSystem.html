<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">{-
   Strong monads on cartesian categories as extension systems,
   i.e., in terms of unit and bind, deriving the rest of the structure
   https://ncatlab.org/nlab/show/extension+system
-}</a>
<a id="191" class="Symbol">{-#</a> <a id="195" class="Keyword">OPTIONS</a> <a id="203" class="Pragma">--lossy-unification</a> <a id="223" class="Symbol">#-}</a>
<a id="227" class="Keyword">module</a> <a id="234" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html" class="Module">Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem</a> <a id="294" class="Keyword">where</a>

<a id="301" class="Keyword">open</a> <a id="306" class="Keyword">import</a> <a id="313" href="Cubical.Foundations.Prelude.html" class="Module">Cubical.Foundations.Prelude</a>

<a id="342" class="Keyword">open</a> <a id="347" class="Keyword">import</a> <a id="354" href="Cubical.Categories.Category.html" class="Module">Cubical.Categories.Category</a>
<a id="382" class="Keyword">open</a> <a id="387" class="Keyword">import</a> <a id="394" href="Cubical.Categories.Functor.html" class="Module">Cubical.Categories.Functor</a> <a id="421" class="Keyword">renaming</a> <a id="430" class="Symbol">(</a><a id="431" href="Cubical.Categories.Functor.Base.html#4002" class="Function Operator">ğŸ™âŸ¨_âŸ©</a> <a id="436" class="Symbol">to</a> <a id="439" class="Function Operator">funcId</a><a id="445" class="Symbol">)</a>
<a id="447" class="Keyword">open</a> <a id="452" class="Keyword">import</a> <a id="459" href="Cubical.Categories.Limits.BinProduct.More.html" class="Module">Cubical.Categories.Limits.BinProduct.More</a>
<a id="501" class="Keyword">open</a> <a id="506" class="Keyword">import</a> <a id="513" href="Cubical.Categories.Limits.Terminal.html" class="Module">Cubical.Categories.Limits.Terminal</a>
<a id="548" class="Keyword">open</a> <a id="553" class="Keyword">import</a> <a id="560" href="Cubical.Categories.Limits.Terminal.More.html" class="Module">Cubical.Categories.Limits.Terminal.More</a>
<a id="600" class="Keyword">open</a> <a id="605" class="Keyword">import</a> <a id="612" href="Cubical.Categories.Limits.Cartesian.Base.html" class="Module">Cubical.Categories.Limits.Cartesian.Base</a>
<a id="653" class="Keyword">open</a> <a id="658" class="Keyword">import</a> <a id="665" href="Cubical.Categories.Comonad.Instances.Environment.html" class="Module">Cubical.Categories.Comonad.Instances.Environment</a>
<a id="714" class="Keyword">open</a> <a id="719" class="Keyword">import</a> <a id="726" href="Cubical.Categories.Monad.ExtensionSystem.html" class="Module">Cubical.Categories.Monad.ExtensionSystem</a> <a id="767" class="Symbol">as</a> <a id="770" class="Module">Monad</a>

<a id="777" class="Keyword">open</a> <a id="782" class="Keyword">import</a> <a id="789" href="Cubical.Tactics.CategorySolver.Reflection.html" class="Module">Cubical.Tactics.CategorySolver.Reflection</a>

<a id="832" class="Keyword">private</a>
  <a id="842" class="Keyword">variable</a>
    <a id="855" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#855" class="Generalizable">â„“</a> <a id="857" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#857" class="Generalizable">â„“&#39;</a> <a id="860" class="Symbol">:</a> <a id="862" href="Agda.Primitive.html#742" class="Postulate">Level</a>

<a id="869" class="Keyword">module</a> <a id="876" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#876" class="Module">_</a> <a id="878" class="Symbol">{</a><a id="879" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#879" class="Bound">C</a> <a id="881" class="Symbol">:</a> <a id="883" href="Cubical.Categories.Category.Base.html#311" class="Record">Category</a> <a id="892" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#855" class="Generalizable">â„“</a> <a id="894" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#857" class="Generalizable">â„“&#39;</a><a id="896" class="Symbol">}</a> <a id="898" class="Symbol">(</a><a id="899" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#899" class="Bound">bp</a> <a id="902" class="Symbol">:</a> <a id="904" href="Cubical.Categories.Limits.BinProduct.More.html#1454" class="Function">BinProducts</a> <a id="916" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#879" class="Bound">C</a><a id="917" class="Symbol">)</a> <a id="919" class="Keyword">where</a>
  <a id="927" class="Keyword">open</a> <a id="932" href="Cubical.Categories.Category.Base.html#311" class="Module">Category</a>
  <a id="943" class="Keyword">open</a> <a id="948" href="Cubical.Categories.Limits.BinProduct.More.html#3363" class="Module">BinProductsNotation</a> <a id="968" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#899" class="Bound">bp</a>
  <a id="973" class="Comment">-- open EnvNotation bp</a>

  <a id="999" class="Keyword">private</a>
    <a id="1011" class="Keyword">variable</a>
      <a id="1026" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#1026" class="Generalizable">Î“</a> <a id="1028" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#1028" class="Generalizable">Î”</a> <a id="1030" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#1030" class="Generalizable">a</a> <a id="1032" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#1032" class="Generalizable">b</a> <a id="1034" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#1034" class="Generalizable">c</a> <a id="1036" class="Symbol">:</a> <a id="1038" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#879" class="Bound">C</a> <a id="1040" class="Symbol">.</a><a id="1041" href="Cubical.Categories.Category.Base.html#429" class="Field">ob</a>
      <a id="1050" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#1050" class="Generalizable">Î³</a> <a id="1052" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#1052" class="Generalizable">Î´</a> <a id="1054" class="Symbol">:</a> <a id="1056" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#879" class="Bound">C</a> <a id="1058" href="Cubical.Categories.Category.Base.html#1210" class="Function Operator">[</a> <a id="1060" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#1028" class="Generalizable">Î”</a> <a id="1062" href="Cubical.Categories.Category.Base.html#1210" class="Function Operator">,</a> <a id="1064" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#1026" class="Generalizable">Î“</a> <a id="1066" href="Cubical.Categories.Category.Base.html#1210" class="Function Operator">]</a>
      <a id="1074" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#1074" class="Generalizable">f</a> <a id="1076" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#1076" class="Generalizable">g</a> <a id="1078" class="Symbol">:</a> <a id="1080" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#879" class="Bound">C</a> <a id="1082" href="Cubical.Categories.Category.Base.html#1210" class="Function Operator">[</a> <a id="1084" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#1030" class="Generalizable">a</a> <a id="1086" href="Cubical.Categories.Category.Base.html#1210" class="Function Operator">,</a> <a id="1088" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#1032" class="Generalizable">b</a> <a id="1090" href="Cubical.Categories.Category.Base.html#1210" class="Function Operator">]</a>
      <a id="1098" class="Comment">-- s t : With Î“ [ a , b ]</a>

  <a id="1127" class="Comment">-- TODO: reformulate this stuff in terms of Displayed categories.</a>
  <a id="1195" class="Comment">--</a>
  <a id="1200" class="Comment">-- This is what Jacobs calls the &quot;simple fibration&quot;</a>

<a id="1253" class="Comment">--   -- Env [ Î³ ][ a , b ] is a map Î” Ã— a â†’ b</a>

<a id="1300" class="Comment">--   -- With is a fibered category over C. With : C â†’ Cat</a>
<a id="1358" class="Comment">--   -- A Strong extension system is a section of this bundle of categories</a>
<a id="1434" class="Comment">--   open ExtensionSystemFor</a>
<a id="1463" class="Comment">--   record StrongExtensionSystem : Type (â„“-max â„“ â„“&#39;) where</a>
<a id="1523" class="Comment">--     field</a>
<a id="1536" class="Comment">--       T : C .ob â†’ C .ob</a>
<a id="1563" class="Comment">--       systems : âˆ€ Î“ â†’ Monad.ExtensionSystemFor (With Î“) T</a>
<a id="1624" class="Comment">--       -- Î· âˆ˜ (Î³ Ã— id) â‰¡ Î·</a>
<a id="1653" class="Comment">--       Î·-natural : (Î³ ^*) âŸª systems Î“ .Î· {a = a} âŸ« â‰¡ systems Î” .Î·</a>
<a id="1721" class="Comment">--       -- bind f âˆ˜ (Î³ Ã— id) â‰¡ bind (f âˆ˜ (Î³ Ã— id))</a>
<a id="1773" class="Comment">--       bind-natural :</a>
<a id="1797" class="Comment">--         (Î³ ^*) âŸª systems Î“ .bind s âŸ« â‰¡ systems Î” .bind ((Î³ ^*) âŸª s âŸ«)</a>
<a id="1870" class="Comment">--   -- | TODO: resulting Î·, bind are natural in all arguments</a>
<a id="1933" class="Comment">--   -- If C further has a terminal object we get an &quot;underlying monad&quot;</a>
<a id="2005" class="Comment">--   -- on C because Envs ğŸ™ â‰… Id</a>
<a id="2038" class="Comment">--   module _ (term : Terminal C) (SE : StrongExtensionSystem) where</a>
<a id="2107" class="Comment">--     open StrongExtensionSystem SE</a>
<a id="2144" class="Comment">--     open TerminalNotation C term</a>
<a id="2180" class="Comment">--     open CartesianCategoryNotation (C , term , bp)</a>
<a id="2234" class="Comment">--     open isIso</a>
<a id="2252" class="Comment">--     -- This follows abstractly from showing (ğŸ™ Ã—-) is equivalent to</a>
<a id="2323" class="Comment">--     -- the identity monad</a>
<a id="2352" class="Comment">--     -- we&#39;ll just be explicit here</a>

<a id="2391" class="Comment">--     E1 = systems ğŸ™</a>
<a id="2413" class="Comment">--     -- f âˆ˜ Ï€â‚‚</a>
<a id="2430" class="Comment">--     toWith1 : C [ a , b ] â†’ With ğŸ™ [ a , b ]</a>
<a id="2478" class="Comment">--     toWith1 = C ._â‹†_ (unitor-l .fst)</a>

<a id="2519" class="Comment">--     -- f âˆ˜ (! , id)</a>
<a id="2542" class="Comment">--     fromWith1 : With ğŸ™ [ a , b ] â†’ C [ a , b ]</a>
<a id="2592" class="Comment">--     fromWith1 = C ._â‹†_ (unitor-l .snd .inv)</a>

<a id="2640" class="Comment">--     fromTo : fromWith1 (toWith1 f) â‰¡ f</a>
<a id="2682" class="Comment">--     fromTo =</a>
<a id="2698" class="Comment">--       sym (C .â‹†Assoc _ _ _) âˆ™</a>
<a id="2731" class="Comment">--       congâ‚‚ (comp&#39; C) refl (unitor-l .snd .sec) âˆ™ C .â‹†IdL _</a>

<a id="2795" class="Comment">--     toFrom : toWith1 (fromWith1 f) â‰¡ f</a>
<a id="2837" class="Comment">--     toFrom =</a>
<a id="2853" class="Comment">--       sym (C .â‹†Assoc _ _ _) âˆ™</a>
<a id="2886" class="Comment">--       congâ‚‚ (comp&#39; C) refl (unitor-l .snd .ret) âˆ™ C .â‹†IdL _</a>

<a id="2950" class="Comment">--     -- TODO: recover a monad on the original category</a>
<a id="3007" class="Comment">--     -- General principle would be that you can transport a monad</a>
<a id="3075" class="Comment">--     -- along an equivalence of categories...</a>
<a id="3123" class="Comment">--     global-ESF : Monad.ExtensionSystemFor C T</a>
<a id="3172" class="Comment">--     global-ESF .Î· = fromWith1 (E1 .Î·)</a>
<a id="3213" class="Comment">--     global-ESF .bind s = fromWith1 (E1 .bind (toWith1 s))</a>
<a id="3274" class="Comment">--     global-ESF .bind-r =</a>
<a id="3302" class="Comment">--       cong fromWith1 (cong (E1 .bind) toFrom) âˆ™</a>
<a id="3353" class="Comment">--       cong fromWith1 (E1 .bind-r) âˆ™ Ã—Î²â‚‚</a>
<a id="3396" class="Comment">--     global-ESF .bind-l {f = f} =</a>
<a id="3432" class="Comment">--       -- (f o Ï€â‚‚)^+ âˆ˜ (!,id) âˆ˜ Î· âˆ˜ (!, id)</a>
<a id="3478" class="Comment">--       -- (f o Ï€â‚‚)^+ âˆ˜ (!,Î·) âˆ˜ Î· âˆ˜ (!, id)</a>
<a id="3523" class="Comment">--       ((C .â‹†Assoc _ _ _) âˆ™ congâ‚‚ (seq&#39; C) refl</a>
<a id="3573" class="Comment">--         (sym (C .â‹†Assoc _ _ _) âˆ™</a>
<a id="3609" class="Comment">--         congâ‚‚ (seq&#39; C)</a>
<a id="3635" class="Comment">--               (,p-natural âˆ™ congâ‚‚ _,p_ (ğŸ™Î·&#39; {g = Ï€â‚}) (C .â‹†IdR _)) refl âˆ™</a>
<a id="3712" class="Comment">--               E1 .bind-l {f = (toWith1 f)} ))</a>
<a id="3761" class="Comment">--       âˆ™ sym (C .â‹†Assoc _ _ _) âˆ™ congâ‚‚ (comp&#39; C) refl Ã—Î²â‚‚ âˆ™ C .â‹†IdL _</a>
<a id="3833" class="Comment">--     -- ((f âˆ˜ Ï€â‚‚)^+ âˆ˜ (! , id)) âˆ˜ ((g âˆ˜ Ï€â‚‚)^+ âˆ˜ (! , id))</a>
<a id="3893" class="Comment">--     global-ESF .bind-comp {f = f}{g = g} =</a>
<a id="3939" class="Comment">--     -- ((f âˆ˜ Ï€â‚‚)^+ âˆ˜ (! , id)) âˆ˜ ((g âˆ˜ Ï€â‚‚)^+ âˆ˜ (! , id))</a>
<a id="3999" class="Comment">--       lem -- f âˆ˜ğŸ™ g = f^+</a>
<a id="4028" class="Comment">--     -- ((f âˆ˜ Ï€â‚‚)^+ âˆ˜ (Ï€â‚ , (g âˆ˜ Ï€â‚‚)^+)) âˆ˜ (! , id)</a>
<a id="4082" class="Comment">--       âˆ™ congâ‚‚ (seq&#39; C) refl (congâ‚‚ (comp&#39; C) refl</a>
<a id="4135" class="Comment">--         (,p-natural âˆ™ congâ‚‚ _,p_ (ğŸ™Î·&#39; {g = Ï€â‚}) (C .â‹†IdR _)) âˆ™ E1 .bind-comp)</a>
<a id="4216" class="Comment">--       âˆ™ congâ‚‚ (seq&#39; C) refl (cong (E1 .bind)</a>
<a id="4264" class="Comment">--               -- (E1 .bind (toWith1 f)) âˆ˜ (Ï€â‚ , (g âˆ˜ Ï€â‚‚))</a>
<a id="4325" class="Comment">--               -- â‰¡ (E1 .bind (toWith f) âˆ˜ g âˆ˜ Ï€â‚‚)</a>
<a id="4378" class="Comment">--               ((congâ‚‚ (comp&#39; C) refl (congâ‚‚ _,p_ ğŸ™Î·&#39; (sym (C .â‹†IdR _)) âˆ™</a>
<a id="4454" class="Comment">--               sym ,p-natural) âˆ™ C .â‹†Assoc _ _ _) âˆ™ C .â‹†Assoc _ _ _))</a>
<a id="4526" class="Comment">--     -- (((f âˆ˜ Ï€â‚‚)^+ âˆ˜ (! , id) âˆ˜ g) âˆ˜ Ï€â‚‚)^+ âˆ˜ (! , id)</a>
<a id="4584" class="Comment">--       where</a>
<a id="4599" class="Comment">--         lem : comp&#39; C (fromWith1 (E1 .bind (toWith1 f)))</a>
<a id="4659" class="Comment">--               (fromWith1 (E1 .bind (toWith1 g))) â‰¡</a>
<a id="4713" class="Comment">--               ((E1 .bind (toWith1 f)) âˆ˜âŸ¨ C âŸ©</a>
<a id="4761" class="Comment">--                 ((!t ,p C .id) âˆ˜âŸ¨ C âŸ© E1 .bind (toWith1 g))) âˆ˜âŸ¨ C âŸ©</a>
<a id="4832" class="Comment">--                   ((!t ,p C .id))</a>
<a id="4869" class="Comment">--         lem = solveCat! C</a>
<a id="4898" class="Comment">--     StrongMonadâ†’Monad : Monad.ExtensionSystem C</a>
<a id="4949" class="Comment">--     StrongMonadâ†’Monad = T , global-ESF</a>

<a id="4992" class="Comment">--     -- TODO: once we establish that T is a functor,</a>
<a id="5047" class="Comment">--     -- we can show the following is natural</a>
<a id="5094" class="Comment">--     Ïƒ : C [ Î“ Ã— T a , T (Î“ Ã— a) ]</a>
<a id="5131" class="Comment">--     Ïƒ {Î“ = Î“} = systems Î“ .bind (fromWith1 (E1 .Î·))</a>
<a id="5186" class="Comment">-- module StrongMonadNotation {C : Category â„“ â„“&#39;}</a>
<a id="5236" class="Comment">--   (bp : BinProducts C) (SE : StrongExtensionSystem bp) where</a>
<a id="5300" class="Comment">--   open Category</a>
<a id="5319" class="Comment">--   open Notation C bp</a>
<a id="5343" class="Comment">--   open EnvNotation bp</a>
<a id="5368" class="Comment">--   open StrongExtensionSystem SE public</a>
<a id="5410" class="Comment">--   private</a>
<a id="5423" class="Comment">--     variable</a>
<a id="5439" class="Comment">--       Î“ Î” a b c : C .ob</a>
<a id="5466" class="Comment">--       Î³ Î´ : C [ Î” , Î“ ]</a>
<a id="5493" class="Comment">--       f g : C [ a , b ]</a>
<a id="5520" class="Comment">--       s t : With Î“ [ a , b ]</a>

<a id="5553" class="Comment">--   open Functor</a>

<a id="5572" class="Comment">--   PKleisli : C .ob â†’ Category _ _</a>
<a id="5609" class="Comment">--   PKleisli Î“ = Monad.Kleisli (With Î“) (T , systems Î“)</a>

<a id="5667" class="Comment">--   PG : (Î“ : C .ob) â†’ Functor (PKleisli Î“) (With Î“)</a>
<a id="5721" class="Comment">--   PG Î“ = Monad.G ((With Î“)) ((T , systems Î“))</a>

<a id="5771" class="Comment">--   bindP : PKleisli Î“ [ a , b ] â†’ With Î“ [ T a , T b ]</a>
<a id="5828" class="Comment">--   bindP {Î“ = Î“} = PG Î“ .F-hom</a>

<a id="5862" class="Comment">--   retP : PKleisli Î“ [ a , a ]</a>
<a id="5895" class="Comment">--   retP {Î“} = PKleisli Î“ .id</a>

<a id="5927" class="Comment">--   bindP-comp : bindP f âˆ˜âŸ¨ With Î“ âŸ© bindP g â‰¡ bindP (bindP f âˆ˜âŸ¨ With Î“ âŸ© g)</a>
<a id="6005" class="Comment">--   bindP-comp {Î“ = Î“} = ExtensionSystemFor.bind-comp (systems Î“)</a>

<a id="6073" class="Comment">--   bindP-l : bindP f âˆ˜âŸ¨ With Î“ âŸ© retP â‰¡ f</a>
<a id="6117" class="Comment">--   bindP-l {Î“ = Î“} = ExtensionSystemFor.bind-l (systems Î“)</a>

<a id="6179" class="Comment">--   bindP-r : bindP (retP {a = a}) â‰¡ With Î“ .id</a>
<a id="6228" class="Comment">--   bindP-r {Î“ = Î“} = ExtensionSystemFor.bind-r (systems Î“)</a>

<a id="6290" class="Comment">--   open Functor</a>

<a id="6309" class="Comment">--   pull : (Î³ : C [ Î” , Î“ ]) â†’ Functor (PKleisli Î“) (PKleisli Î”)</a>
<a id="6375" class="Comment">--   pull Î³ .F-ob = Î» z â†’ z</a>
<a id="6403" class="Comment">--   pull Î³ .F-hom f = (Î³ ^*) âŸª f âŸ«</a>
<a id="6439" class="Comment">--   pull Î³ .F-id = Î·-natural</a>
<a id="6469" class="Comment">--   pull {Î” = Î”} Î³ .F-seq f g =</a>
<a id="6502" class="Comment">--     (Î³ ^*) .F-seq _ _ âˆ™ congâ‚‚ (seq&#39; (With Î”)) refl bind-natural</a>
</pre></body></html>