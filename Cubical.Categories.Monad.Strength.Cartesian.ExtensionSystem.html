<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">{-
   Strong monads on cartesian categories as extension systems,
   i.e., in terms of unit and bind, deriving the rest of the structure
   https://ncatlab.org/nlab/show/extension+system
-}</a>
<a id="191" class="Symbol">{-#</a> <a id="195" class="Keyword">OPTIONS</a> <a id="203" class="Pragma">--lossy-unification</a> <a id="223" class="Symbol">#-}</a>
<a id="227" class="Keyword">module</a> <a id="234" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html" class="Module">Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem</a> <a id="294" class="Keyword">where</a>

<a id="301" class="Keyword">open</a> <a id="306" class="Keyword">import</a> <a id="313" href="Cubical.Foundations.Prelude.html" class="Module">Cubical.Foundations.Prelude</a>

<a id="342" class="Keyword">open</a> <a id="347" class="Keyword">import</a> <a id="354" href="Cubical.Categories.Category.html" class="Module">Cubical.Categories.Category</a>
<a id="382" class="Keyword">open</a> <a id="387" class="Keyword">import</a> <a id="394" href="Cubical.Categories.Functor.html" class="Module">Cubical.Categories.Functor</a> <a id="421" class="Keyword">renaming</a> <a id="430" class="Symbol">(</a><a id="431" href="Cubical.Categories.Functor.Base.html#4002" class="Function Operator">𝟙⟨_⟩</a> <a id="436" class="Symbol">to</a> <a id="439" class="Function Operator">funcId</a><a id="445" class="Symbol">)</a>
<a id="447" class="Keyword">open</a> <a id="452" class="Keyword">import</a> <a id="459" href="Cubical.Categories.Limits.BinProduct.More.html" class="Module">Cubical.Categories.Limits.BinProduct.More</a>
<a id="501" class="Keyword">open</a> <a id="506" class="Keyword">import</a> <a id="513" href="Cubical.Categories.Limits.Terminal.html" class="Module">Cubical.Categories.Limits.Terminal</a>
<a id="548" class="Keyword">open</a> <a id="553" class="Keyword">import</a> <a id="560" href="Cubical.Categories.Limits.Terminal.More.html" class="Module">Cubical.Categories.Limits.Terminal.More</a>
<a id="600" class="Keyword">open</a> <a id="605" class="Keyword">import</a> <a id="612" href="Cubical.Categories.Limits.Cartesian.Base.html" class="Module">Cubical.Categories.Limits.Cartesian.Base</a>
<a id="653" class="Keyword">open</a> <a id="658" class="Keyword">import</a> <a id="665" href="Cubical.Categories.Comonad.Instances.Environment.html" class="Module">Cubical.Categories.Comonad.Instances.Environment</a>
<a id="714" class="Keyword">open</a> <a id="719" class="Keyword">import</a> <a id="726" href="Cubical.Categories.Monad.ExtensionSystem.html" class="Module">Cubical.Categories.Monad.ExtensionSystem</a> <a id="767" class="Symbol">as</a> <a id="770" class="Module">Monad</a>

<a id="777" class="Keyword">open</a> <a id="782" class="Keyword">import</a> <a id="789" href="Cubical.Tactics.CategorySolver.Reflection.html" class="Module">Cubical.Tactics.CategorySolver.Reflection</a>

<a id="832" class="Keyword">private</a>
  <a id="842" class="Keyword">variable</a>
    <a id="855" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#855" class="Generalizable">ℓ</a> <a id="857" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#857" class="Generalizable">ℓ&#39;</a> <a id="860" class="Symbol">:</a> <a id="862" href="Agda.Primitive.html#742" class="Postulate">Level</a>

<a id="869" class="Keyword">module</a> <a id="876" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#876" class="Module">_</a> <a id="878" class="Symbol">{</a><a id="879" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#879" class="Bound">C</a> <a id="881" class="Symbol">:</a> <a id="883" href="Cubical.Categories.Category.Base.html#311" class="Record">Category</a> <a id="892" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#855" class="Generalizable">ℓ</a> <a id="894" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#857" class="Generalizable">ℓ&#39;</a><a id="896" class="Symbol">}</a> <a id="898" class="Symbol">(</a><a id="899" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#899" class="Bound">bp</a> <a id="902" class="Symbol">:</a> <a id="904" href="Cubical.Categories.Limits.BinProduct.More.html#1454" class="Function">BinProducts</a> <a id="916" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#879" class="Bound">C</a><a id="917" class="Symbol">)</a> <a id="919" class="Keyword">where</a>
  <a id="927" class="Keyword">open</a> <a id="932" href="Cubical.Categories.Category.Base.html#311" class="Module">Category</a>
  <a id="943" class="Keyword">open</a> <a id="948" href="Cubical.Categories.Limits.BinProduct.More.html#3363" class="Module">BinProductsNotation</a> <a id="968" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#899" class="Bound">bp</a>
  <a id="973" class="Comment">-- open EnvNotation bp</a>

  <a id="999" class="Keyword">private</a>
    <a id="1011" class="Keyword">variable</a>
      <a id="1026" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#1026" class="Generalizable">Γ</a> <a id="1028" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#1028" class="Generalizable">Δ</a> <a id="1030" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#1030" class="Generalizable">a</a> <a id="1032" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#1032" class="Generalizable">b</a> <a id="1034" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#1034" class="Generalizable">c</a> <a id="1036" class="Symbol">:</a> <a id="1038" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#879" class="Bound">C</a> <a id="1040" class="Symbol">.</a><a id="1041" href="Cubical.Categories.Category.Base.html#429" class="Field">ob</a>
      <a id="1050" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#1050" class="Generalizable">γ</a> <a id="1052" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#1052" class="Generalizable">δ</a> <a id="1054" class="Symbol">:</a> <a id="1056" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#879" class="Bound">C</a> <a id="1058" href="Cubical.Categories.Category.Base.html#1210" class="Function Operator">[</a> <a id="1060" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#1028" class="Generalizable">Δ</a> <a id="1062" href="Cubical.Categories.Category.Base.html#1210" class="Function Operator">,</a> <a id="1064" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#1026" class="Generalizable">Γ</a> <a id="1066" href="Cubical.Categories.Category.Base.html#1210" class="Function Operator">]</a>
      <a id="1074" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#1074" class="Generalizable">f</a> <a id="1076" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#1076" class="Generalizable">g</a> <a id="1078" class="Symbol">:</a> <a id="1080" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#879" class="Bound">C</a> <a id="1082" href="Cubical.Categories.Category.Base.html#1210" class="Function Operator">[</a> <a id="1084" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#1030" class="Generalizable">a</a> <a id="1086" href="Cubical.Categories.Category.Base.html#1210" class="Function Operator">,</a> <a id="1088" href="Cubical.Categories.Monad.Strength.Cartesian.ExtensionSystem.html#1032" class="Generalizable">b</a> <a id="1090" href="Cubical.Categories.Category.Base.html#1210" class="Function Operator">]</a>
      <a id="1098" class="Comment">-- s t : With Γ [ a , b ]</a>

  <a id="1127" class="Comment">-- TODO: reformulate this stuff in terms of Displayed categories.</a>
  <a id="1195" class="Comment">--</a>
  <a id="1200" class="Comment">-- This is what Jacobs calls the &quot;simple fibration&quot;</a>

<a id="1253" class="Comment">--   -- Env [ γ ][ a , b ] is a map Δ × a → b</a>

<a id="1300" class="Comment">--   -- With is a fibered category over C. With : C → Cat</a>
<a id="1358" class="Comment">--   -- A Strong extension system is a section of this bundle of categories</a>
<a id="1434" class="Comment">--   open ExtensionSystemFor</a>
<a id="1463" class="Comment">--   record StrongExtensionSystem : Type (ℓ-max ℓ ℓ&#39;) where</a>
<a id="1523" class="Comment">--     field</a>
<a id="1536" class="Comment">--       T : C .ob → C .ob</a>
<a id="1563" class="Comment">--       systems : ∀ Γ → Monad.ExtensionSystemFor (With Γ) T</a>
<a id="1624" class="Comment">--       -- η ∘ (γ × id) ≡ η</a>
<a id="1653" class="Comment">--       η-natural : (γ ^*) ⟪ systems Γ .η {a = a} ⟫ ≡ systems Δ .η</a>
<a id="1721" class="Comment">--       -- bind f ∘ (γ × id) ≡ bind (f ∘ (γ × id))</a>
<a id="1773" class="Comment">--       bind-natural :</a>
<a id="1797" class="Comment">--         (γ ^*) ⟪ systems Γ .bind s ⟫ ≡ systems Δ .bind ((γ ^*) ⟪ s ⟫)</a>
<a id="1870" class="Comment">--   -- | TODO: resulting η, bind are natural in all arguments</a>
<a id="1933" class="Comment">--   -- If C further has a terminal object we get an &quot;underlying monad&quot;</a>
<a id="2005" class="Comment">--   -- on C because Envs 𝟙 ≅ Id</a>
<a id="2038" class="Comment">--   module _ (term : Terminal C) (SE : StrongExtensionSystem) where</a>
<a id="2107" class="Comment">--     open StrongExtensionSystem SE</a>
<a id="2144" class="Comment">--     open TerminalNotation C term</a>
<a id="2180" class="Comment">--     open CartesianCategoryNotation (C , term , bp)</a>
<a id="2234" class="Comment">--     open isIso</a>
<a id="2252" class="Comment">--     -- This follows abstractly from showing (𝟙 ×-) is equivalent to</a>
<a id="2323" class="Comment">--     -- the identity monad</a>
<a id="2352" class="Comment">--     -- we&#39;ll just be explicit here</a>

<a id="2391" class="Comment">--     E1 = systems 𝟙</a>
<a id="2413" class="Comment">--     -- f ∘ π₂</a>
<a id="2430" class="Comment">--     toWith1 : C [ a , b ] → With 𝟙 [ a , b ]</a>
<a id="2478" class="Comment">--     toWith1 = C ._⋆_ (unitor-l .fst)</a>

<a id="2519" class="Comment">--     -- f ∘ (! , id)</a>
<a id="2542" class="Comment">--     fromWith1 : With 𝟙 [ a , b ] → C [ a , b ]</a>
<a id="2592" class="Comment">--     fromWith1 = C ._⋆_ (unitor-l .snd .inv)</a>

<a id="2640" class="Comment">--     fromTo : fromWith1 (toWith1 f) ≡ f</a>
<a id="2682" class="Comment">--     fromTo =</a>
<a id="2698" class="Comment">--       sym (C .⋆Assoc _ _ _) ∙</a>
<a id="2731" class="Comment">--       cong₂ (comp&#39; C) refl (unitor-l .snd .sec) ∙ C .⋆IdL _</a>

<a id="2795" class="Comment">--     toFrom : toWith1 (fromWith1 f) ≡ f</a>
<a id="2837" class="Comment">--     toFrom =</a>
<a id="2853" class="Comment">--       sym (C .⋆Assoc _ _ _) ∙</a>
<a id="2886" class="Comment">--       cong₂ (comp&#39; C) refl (unitor-l .snd .ret) ∙ C .⋆IdL _</a>

<a id="2950" class="Comment">--     -- TODO: recover a monad on the original category</a>
<a id="3007" class="Comment">--     -- General principle would be that you can transport a monad</a>
<a id="3075" class="Comment">--     -- along an equivalence of categories...</a>
<a id="3123" class="Comment">--     global-ESF : Monad.ExtensionSystemFor C T</a>
<a id="3172" class="Comment">--     global-ESF .η = fromWith1 (E1 .η)</a>
<a id="3213" class="Comment">--     global-ESF .bind s = fromWith1 (E1 .bind (toWith1 s))</a>
<a id="3274" class="Comment">--     global-ESF .bind-r =</a>
<a id="3302" class="Comment">--       cong fromWith1 (cong (E1 .bind) toFrom) ∙</a>
<a id="3353" class="Comment">--       cong fromWith1 (E1 .bind-r) ∙ ×β₂</a>
<a id="3396" class="Comment">--     global-ESF .bind-l {f = f} =</a>
<a id="3432" class="Comment">--       -- (f o π₂)^+ ∘ (!,id) ∘ η ∘ (!, id)</a>
<a id="3478" class="Comment">--       -- (f o π₂)^+ ∘ (!,η) ∘ η ∘ (!, id)</a>
<a id="3523" class="Comment">--       ((C .⋆Assoc _ _ _) ∙ cong₂ (seq&#39; C) refl</a>
<a id="3573" class="Comment">--         (sym (C .⋆Assoc _ _ _) ∙</a>
<a id="3609" class="Comment">--         cong₂ (seq&#39; C)</a>
<a id="3635" class="Comment">--               (,p-natural ∙ cong₂ _,p_ (𝟙η&#39; {g = π₁}) (C .⋆IdR _)) refl ∙</a>
<a id="3712" class="Comment">--               E1 .bind-l {f = (toWith1 f)} ))</a>
<a id="3761" class="Comment">--       ∙ sym (C .⋆Assoc _ _ _) ∙ cong₂ (comp&#39; C) refl ×β₂ ∙ C .⋆IdL _</a>
<a id="3833" class="Comment">--     -- ((f ∘ π₂)^+ ∘ (! , id)) ∘ ((g ∘ π₂)^+ ∘ (! , id))</a>
<a id="3893" class="Comment">--     global-ESF .bind-comp {f = f}{g = g} =</a>
<a id="3939" class="Comment">--     -- ((f ∘ π₂)^+ ∘ (! , id)) ∘ ((g ∘ π₂)^+ ∘ (! , id))</a>
<a id="3999" class="Comment">--       lem -- f ∘𝟙 g = f^+</a>
<a id="4028" class="Comment">--     -- ((f ∘ π₂)^+ ∘ (π₁ , (g ∘ π₂)^+)) ∘ (! , id)</a>
<a id="4082" class="Comment">--       ∙ cong₂ (seq&#39; C) refl (cong₂ (comp&#39; C) refl</a>
<a id="4135" class="Comment">--         (,p-natural ∙ cong₂ _,p_ (𝟙η&#39; {g = π₁}) (C .⋆IdR _)) ∙ E1 .bind-comp)</a>
<a id="4216" class="Comment">--       ∙ cong₂ (seq&#39; C) refl (cong (E1 .bind)</a>
<a id="4264" class="Comment">--               -- (E1 .bind (toWith1 f)) ∘ (π₁ , (g ∘ π₂))</a>
<a id="4325" class="Comment">--               -- ≡ (E1 .bind (toWith f) ∘ g ∘ π₂)</a>
<a id="4378" class="Comment">--               ((cong₂ (comp&#39; C) refl (cong₂ _,p_ 𝟙η&#39; (sym (C .⋆IdR _)) ∙</a>
<a id="4454" class="Comment">--               sym ,p-natural) ∙ C .⋆Assoc _ _ _) ∙ C .⋆Assoc _ _ _))</a>
<a id="4526" class="Comment">--     -- (((f ∘ π₂)^+ ∘ (! , id) ∘ g) ∘ π₂)^+ ∘ (! , id)</a>
<a id="4584" class="Comment">--       where</a>
<a id="4599" class="Comment">--         lem : comp&#39; C (fromWith1 (E1 .bind (toWith1 f)))</a>
<a id="4659" class="Comment">--               (fromWith1 (E1 .bind (toWith1 g))) ≡</a>
<a id="4713" class="Comment">--               ((E1 .bind (toWith1 f)) ∘⟨ C ⟩</a>
<a id="4761" class="Comment">--                 ((!t ,p C .id) ∘⟨ C ⟩ E1 .bind (toWith1 g))) ∘⟨ C ⟩</a>
<a id="4832" class="Comment">--                   ((!t ,p C .id))</a>
<a id="4869" class="Comment">--         lem = solveCat! C</a>
<a id="4898" class="Comment">--     StrongMonad→Monad : Monad.ExtensionSystem C</a>
<a id="4949" class="Comment">--     StrongMonad→Monad = T , global-ESF</a>

<a id="4992" class="Comment">--     -- TODO: once we establish that T is a functor,</a>
<a id="5047" class="Comment">--     -- we can show the following is natural</a>
<a id="5094" class="Comment">--     σ : C [ Γ × T a , T (Γ × a) ]</a>
<a id="5131" class="Comment">--     σ {Γ = Γ} = systems Γ .bind (fromWith1 (E1 .η))</a>
<a id="5186" class="Comment">-- module StrongMonadNotation {C : Category ℓ ℓ&#39;}</a>
<a id="5236" class="Comment">--   (bp : BinProducts C) (SE : StrongExtensionSystem bp) where</a>
<a id="5300" class="Comment">--   open Category</a>
<a id="5319" class="Comment">--   open Notation C bp</a>
<a id="5343" class="Comment">--   open EnvNotation bp</a>
<a id="5368" class="Comment">--   open StrongExtensionSystem SE public</a>
<a id="5410" class="Comment">--   private</a>
<a id="5423" class="Comment">--     variable</a>
<a id="5439" class="Comment">--       Γ Δ a b c : C .ob</a>
<a id="5466" class="Comment">--       γ δ : C [ Δ , Γ ]</a>
<a id="5493" class="Comment">--       f g : C [ a , b ]</a>
<a id="5520" class="Comment">--       s t : With Γ [ a , b ]</a>

<a id="5553" class="Comment">--   open Functor</a>

<a id="5572" class="Comment">--   PKleisli : C .ob → Category _ _</a>
<a id="5609" class="Comment">--   PKleisli Γ = Monad.Kleisli (With Γ) (T , systems Γ)</a>

<a id="5667" class="Comment">--   PG : (Γ : C .ob) → Functor (PKleisli Γ) (With Γ)</a>
<a id="5721" class="Comment">--   PG Γ = Monad.G ((With Γ)) ((T , systems Γ))</a>

<a id="5771" class="Comment">--   bindP : PKleisli Γ [ a , b ] → With Γ [ T a , T b ]</a>
<a id="5828" class="Comment">--   bindP {Γ = Γ} = PG Γ .F-hom</a>

<a id="5862" class="Comment">--   retP : PKleisli Γ [ a , a ]</a>
<a id="5895" class="Comment">--   retP {Γ} = PKleisli Γ .id</a>

<a id="5927" class="Comment">--   bindP-comp : bindP f ∘⟨ With Γ ⟩ bindP g ≡ bindP (bindP f ∘⟨ With Γ ⟩ g)</a>
<a id="6005" class="Comment">--   bindP-comp {Γ = Γ} = ExtensionSystemFor.bind-comp (systems Γ)</a>

<a id="6073" class="Comment">--   bindP-l : bindP f ∘⟨ With Γ ⟩ retP ≡ f</a>
<a id="6117" class="Comment">--   bindP-l {Γ = Γ} = ExtensionSystemFor.bind-l (systems Γ)</a>

<a id="6179" class="Comment">--   bindP-r : bindP (retP {a = a}) ≡ With Γ .id</a>
<a id="6228" class="Comment">--   bindP-r {Γ = Γ} = ExtensionSystemFor.bind-r (systems Γ)</a>

<a id="6290" class="Comment">--   open Functor</a>

<a id="6309" class="Comment">--   pull : (γ : C [ Δ , Γ ]) → Functor (PKleisli Γ) (PKleisli Δ)</a>
<a id="6375" class="Comment">--   pull γ .F-ob = λ z → z</a>
<a id="6403" class="Comment">--   pull γ .F-hom f = (γ ^*) ⟪ f ⟫</a>
<a id="6439" class="Comment">--   pull γ .F-id = η-natural</a>
<a id="6469" class="Comment">--   pull {Δ = Δ} γ .F-seq f g =</a>
<a id="6502" class="Comment">--     (γ ^*) .F-seq _ _ ∙ cong₂ (seq&#39; (With Δ)) refl bind-natural</a>
</pre></body></html>