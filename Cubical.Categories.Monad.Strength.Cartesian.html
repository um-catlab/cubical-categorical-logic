<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Cubical.Categories.Monad.Strength.Cartesian</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">-- {- Strength for a monad on a cartesian category is a bit simpler</a>
<a id="69" class="Comment">--   than for monoidal categories -}</a>
<a id="106" class="Comment">{- Unfortunately this is very slow but lossy unification breaks it -}</a>
<a id="176" class="Symbol">{-#</a> <a id="180" class="Keyword">OPTIONS</a> <a id="188" class="Pragma">--safe</a> <a id="195" class="Symbol">#-}</a>
<a id="199" class="Keyword">module</a> <a id="206" href="Cubical.Categories.Monad.Strength.Cartesian.html" class="Module">Cubical.Categories.Monad.Strength.Cartesian</a> <a id="250" class="Keyword">where</a>

<a id="257" class="Comment">-- open import Cubical.Foundations.Prelude</a>
<a id="300" class="Comment">-- open import Cubical.Categories.Category hiding (isIso)</a>
<a id="358" class="Comment">-- open import Cubical.Categories.Constructions.BinProduct</a>
<a id="417" class="Comment">-- open import Cubical.Categories.Functor</a>
<a id="459" class="Comment">-- open import Cubical.Categories.NaturalTransformation</a>
<a id="515" class="Comment">-- open import Cubical.Categories.Monad.Base</a>
<a id="560" class="Comment">-- open import Cubical.Categories.Comonad.Base</a>
<a id="607" class="Comment">-- open import Cubical.Categories.Comonad.Instances.Environment</a>
<a id="671" class="Comment">-- open import Cubical.Categories.Limits.BinProduct</a>
<a id="723" class="Comment">-- open import Cubical.Categories.Limits.BinProduct.More</a>
<a id="780" class="Comment">-- open import Cubical.Categories.DistributiveLaw.ComonadOverMonad.Base</a>
<a id="852" class="Comment">--open import</a>
<a id="866" class="Comment">-- Cubical.Categories.DistributiveLaw.ComonadOverMonad.BiKleisli.Base</a>
<a id="936" class="Comment">-- open import Cubical.Categories.Monad.Kleisli</a>

<a id="985" class="Comment">-- open import Cubical.Tactics.FunctorSolver.Reflection</a>
<a id="1041" class="Comment">-- open import Cubical.Tactics.CategorySolver.Reflection</a>

<a id="1099" class="Comment">-- private</a>
<a id="1110" class="Comment">--   variable</a>
<a id="1124" class="Comment">--     ℓ ℓ&#39; : Level</a>

<a id="1145" class="Comment">-- module _ {C : Category ℓ ℓ&#39;} (bp : BinProducts C) (T : Monad C) where</a>
<a id="1218" class="Comment">--   open Notation C bp</a>
<a id="1242" class="Comment">--   open NatTrans</a>
<a id="1261" class="Comment">--   StrengthTrans : Type _</a>
<a id="1289" class="Comment">--   StrengthTrans = NatTrans (×pF ∘F (Id {C = C} ×F T .fst)) (T .fst ∘F ×pF)</a>
<a id="1367" class="Comment">--   open Category C</a>
<a id="1388" class="Comment">--   open Functor</a>

<a id="1407" class="Comment">--   Env&#39; : ob → Comonad C</a>
<a id="1434" class="Comment">--   Env&#39; Γ = Env Γ (bp Γ)</a>

<a id="1462" class="Comment">--   fix-Γ : ∀ Γ → StrengthTrans →</a>
<a id="1497" class="Comment">--     NatTrans (Env&#39; Γ .fst ∘F T .fst) ((T .fst) ∘F Env&#39; Γ .fst)</a>
<a id="1563" class="Comment">--   fix-Γ Γ σ .N-ob x = σ ⟦ Γ , x ⟧</a>
<a id="1600" class="Comment">--   -- This is the downside of removing the id in ×pF</a>
<a id="1655" class="Comment">--   fix-Γ Γ σ .N-hom f =</a>
<a id="1681" class="Comment">--     cong₂ _⋆_ (sym (×pF-with-agrees Γ)) refl ∙</a>
<a id="1731" class="Comment">--       σ .N-hom _ ∙ cong₂ _⋆_ refl (cong (T .fst ⟪_⟫) (×pF-with-agrees Γ))</a>

<a id="1809" class="Comment">--   Strength : Type _</a>
<a id="1832" class="Comment">--   Strength =</a>
<a id="1848" class="Comment">--     Σ[ σ ∈ StrengthTrans ]</a>
<a id="1878" class="Comment">--     ∀ Γ → IsDistributiveLaw (Env&#39; Γ) T (fix-Γ Γ σ)</a>

<a id="1933" class="Comment">--   module _ (σ : Strength) where</a>
<a id="1968" class="Comment">--     open IsMonad (T .snd)</a>
<a id="1997" class="Comment">--     open IsComonad</a>
<a id="2019" class="Comment">--     open IsDistributiveLaw</a>
<a id="2049" class="Comment">--     strength-law : (Γ : ob) → DistributiveLaw (Env&#39; Γ) T</a>
<a id="2109" class="Comment">--     strength-law Γ = (fix-Γ Γ (σ .fst)) , (σ .snd Γ)</a>

<a id="2166" class="Comment">--     change-of-base : ∀ {Δ Γ} (γ : Hom[ Δ , Γ ]) →</a>
<a id="2219" class="Comment">--       ComonadMorphism (strength-law Γ) (strength-law Δ)</a>
<a id="2278" class="Comment">--     change-of-base γ .fst = push bp γ</a>
<a id="2319" class="Comment">--     change-of-base γ .snd = makeNatTransPath (funExt (λ x →</a>
<a id="2382" class="Comment">--       (cong₂ _∘_ refl (cong₂ _×p_ refl (sym (T .fst .F-id))))</a>
<a id="2447" class="Comment">--       ∙ σ .fst .N-hom _ -- this doesn&#39;t work with --lossy-unification</a>
<a id="2520" class="Comment">--       ))</a>

<a id="2533" class="Comment">--     IndexedKleisli : ∀ (Γ : ob) → Category _ _</a>
<a id="2583" class="Comment">--     IndexedKleisli Γ = BiKleisli (Env&#39; Γ) T (strength-law Γ)</a>

<a id="2648" class="Comment">--     -- I suppose this actually works for any comonad...</a>
<a id="2707" class="Comment">--     wkF : (Γ : ob) → Functor (Kleisli T) (IndexedKleisli Γ)</a>
<a id="2770" class="Comment">--     wkF Γ .F-ob x = x</a>
<a id="2795" class="Comment">--     wkF Γ .F-hom f = f ∘ Env&#39; Γ .snd .ε ⟦ _ ⟧ -- π₂ is the counit of Env&#39;!</a>
<a id="2873" class="Comment">--     wkF Γ .F-id = refl</a>
<a id="2899" class="Comment">--     wkF Γ .F-seq {x}{y}{z}f g =</a>
<a id="2934" class="Comment">--       -- μ ∘ T g ∘ f ∘ π₂</a>
<a id="2963" class="Comment">--       sym (⋆Assoc _ _ _)</a>
<a id="2991" class="Comment">--       -- μ ∘ T g ∘ π₂ ∘ (π₁ , f ∘ π₂)</a>
<a id="3032" class="Comment">--       ∙ cong₂ _∘_ refl</a>
<a id="3058" class="Comment">--         (sym ×β₂ ∙ (cong₂ _⋆_ refl (sym ((ε-law (strength-law Γ .snd))))))</a>
<a id="3136" class="Comment">--       ∙ lem0</a>
<a id="3152" class="Comment">--       -- μ ∘ T g ∘ T π₂ ∘ σ ∘ (π₁ , f ∘ π₂)</a>
<a id="3199" class="Comment">--       -- μ ∘ T (g ∘ π₂) ∘ σ ∘ (π₁ , f ∘ π₂)</a>
<a id="3246" class="Comment">--       ∙ cong₂ _∘_ refl</a>
<a id="3272" class="Comment">--         ((cong₂ _∘_ refl (cong₂ _,p_ (sym ×β₁) (sym (⋆IdL _) ∙</a>
<a id="3338" class="Comment">--           cong₂ _∘_ refl (sym ×β₂) ∙ ⋆Assoc _ _ _) ∙ sym ,p-natural)))</a>
<a id="3412" class="Comment">--       -- μ ∘ T (g ∘ π₂) ∘ σ ∘ (π₁ ,p f ∘ π₂ ∘ π₂ ) ∘ (π₁ , id)</a>
<a id="3478" class="Comment">--       where</a>
<a id="3493" class="Comment">--         lem0 : ((μ ⟦ _ ⟧ ∘ (T .fst ⟪ g ⟫)) ∘</a>
<a id="3541" class="Comment">--           (T .fst ⟪ Env&#39; Γ .snd .ε ⟦ _ ⟧ ⟫ ∘ σ .fst ⟦ _ ⟧) ∘</a>
<a id="3605" class="Comment">--           (π₁ ,p (f ∘ π₂)))</a>
<a id="3636" class="Comment">--                ≡ (bp Γ (F-ob (T .fst) y)</a>
<a id="3680" class="Comment">--                  .BinProduct.univProp (bp Γ x .BinProduct.binProdPr₁)</a>
<a id="3753" class="Comment">--                    (bp Γ x .BinProduct.binProdPr₂ ⋆ f)</a>
<a id="3811" class="Comment">--                    .fst .fst ⋆ N-ob (σ .fst) (Γ , y)) ⋆ F-hom (T .fst)</a>
<a id="3885" class="Comment">--               (bp Γ y .BinProduct.binProdPr₂ ⋆ g) ⋆ N-ob</a>
<a id="3945" class="Comment">--               (IsMonad.μ (T .snd)) z</a>
<a id="3985" class="Comment">--         lem0 = solveFunctor! C C (T .fst)</a>
</pre></body></html>