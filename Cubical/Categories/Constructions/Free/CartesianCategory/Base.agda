{-# OPTIONS --safe #-}
module Cubical.Categories.Constructions.Free.CartesianCategory.Base where

open import Cubical.Foundations.Prelude
open import Cubical.Categories.Category
open import Cubical.Categories.CartesianCategory.BinaryCartesianCategory
open import Cubical.Categories.Constructions.Free.CartesianCategory.ProductQuiver
open import Cubical.Categories.Functor
open import Cubical.Foundations.Transport
open import Cubical.Foundations.Path
open BinaryCartesianCategory
open StrictCartesianFunctor
open Category
open ProductQuiver
open Functor

private variable
  â„“ â„“' â„“'' â„“''' : Level
  â„“q â„“q' : Level
  â„“c â„“c' : Level
  â„“d â„“d' : Level

module _ (Q : ProductQuiver â„“q â„“q') where
  open import Cubical.Categories.Limits.BinProduct
  open import Cubical.Categories.Limits.BinProduct.More
  open BinProduct
  open Notation

  ProdTypeExpr' = ProdTypeExpr (Q .vertex)

  data EdgeExpr[_,_] : ProdTypeExpr' â†’ ProdTypeExpr' â†’ Type (â„“-max â„“q â„“q') where
    â†‘â‚‘ : (e : Q .edge) â†’ EdgeExpr[ Q .dom e , Q .cod e ]
    idâ‚‘ : âˆ€{A} â†’ EdgeExpr[ A , A ]
    _â‹†â‚‘_ : âˆ€{A B C} â†’ EdgeExpr[ A , B ] â†’ EdgeExpr[ B , C ] â†’ EdgeExpr[ A , C ]
    â‹†â‚‘IdL : âˆ€{A B}(f : EdgeExpr[ A , B ]) â†’ idâ‚‘ â‹†â‚‘ f â‰¡ f
    â‹†â‚‘IdR : âˆ€{A B}(f : EdgeExpr[ A , B ]) â†’ f â‹†â‚‘ idâ‚‘ â‰¡ f
    â‹†â‚‘Assoc : âˆ€{A B C D}(f : EdgeExpr[ A , B ])(g : EdgeExpr[ B , C ])(h : EdgeExpr[ C , D ]) â†’ (f â‹†â‚‘ g) â‹†â‚‘ h â‰¡ f â‹†â‚‘ (g â‹†â‚‘ h)
    isSetEdgeExpr : âˆ€{A B} â†’ isSet EdgeExpr[ A , B ]
    Ï€â‚â‚‘ : âˆ€{A B} â†’ EdgeExpr[ A Ã—Ì¬ B , A ]
    Ï€â‚‚â‚‘ : âˆ€{A B} â†’ EdgeExpr[ A Ã—Ì¬ B , B ]
    âŸ¨_,â‚‘_âŸ© : âˆ€{A B C} â†’ EdgeExpr[ C , A ] â†’ EdgeExpr[ C , B ] â†’ EdgeExpr[ C , A Ã—Ì¬ B ]
    !â‚‘ : âˆ€{A} â†’ EdgeExpr[ A , âŠ¤Ì¬ ]
    Ã—Ì¬Î²â‚ : âˆ€{A B C}{f : EdgeExpr[ C , A ]}{g : EdgeExpr[ C , B ]} â†’ âŸ¨ f ,â‚‘ g âŸ© â‹†â‚‘ Ï€â‚â‚‘ â‰¡ f
    Ã—Ì¬Î²â‚‚ : âˆ€{A B C}{f : EdgeExpr[ C , A ]}{g : EdgeExpr[ C , B ]} â†’ âŸ¨ f ,â‚‘ g âŸ© â‹†â‚‘ Ï€â‚‚â‚‘ â‰¡ g
    Ã—Ì¬Î· : âˆ€{A B C}{f : EdgeExpr[ C , A Ã—Ì¬ B ]} â†’ âŸ¨ f â‹†â‚‘ Ï€â‚â‚‘ ,â‚‘ f â‹†â‚‘ Ï€â‚‚â‚‘ âŸ© â‰¡ f
    âŠ¤Ì¬Î· : âˆ€{A}{f : EdgeExpr[ A , âŠ¤Ì¬ ]} â†’ f â‰¡ !â‚‘

  FreeCartesianCategory : BinaryCartesianCategory _ _
  FreeCartesianCategory .cat .ob = ProdTypeExpr'
  FreeCartesianCategory .cat .Hom[_,_] = EdgeExpr[_,_]
  FreeCartesianCategory .cat .id = idâ‚‘
  FreeCartesianCategory .cat ._â‹†_ = _â‹†â‚‘_
  FreeCartesianCategory .cat .â‹†IdL = â‹†â‚‘IdL
  FreeCartesianCategory .cat .â‹†IdR = â‹†â‚‘IdR
  FreeCartesianCategory .cat .â‹†Assoc = â‹†â‚‘Assoc
  FreeCartesianCategory .cat .isSetHom = isSetEdgeExpr
  FreeCartesianCategory .prod A B .binProdOb = A Ã—Ì¬ B
  FreeCartesianCategory .prod A B .binProdPrâ‚ = Ï€â‚â‚‘
  FreeCartesianCategory .prod A B .binProdPrâ‚‚ = Ï€â‚‚â‚‘
  FreeCartesianCategory .prod A B .univProp f g = (âŸ¨ f ,â‚‘ g âŸ© , Ã—Ì¬Î²â‚ , Ã—Ì¬Î²â‚‚) ,
    Î» (h , p , q) â†’
      Î» i â†’ sym (Ã—Î·-lemma h p q) i , isSetâ†’isSet' isSetEdgeExpr Ã—Ì¬Î²â‚ p (congS (Î» x â†’ x â‹†â‚‘ Ï€â‚â‚‘) (sym (Ã—Î·-lemma h p q))) refl i , isSetâ†’isSet' isSetEdgeExpr Ã—Ì¬Î²â‚‚ q (congS (Î» x â†’ x â‹†â‚‘ Ï€â‚‚â‚‘) (sym (Ã—Î·-lemma h p q))) refl i
    where
    -- this direction has more `sym` s, but I like it more 
    Ã—Î·-lemma : âˆ€{A B C f g} â†’ (h : EdgeExpr[ C , A Ã—Ì¬ B ]) â†’ h â‹†â‚‘ Ï€â‚â‚‘ â‰¡ f â†’ h â‹†â‚‘ Ï€â‚‚â‚‘ â‰¡ g â†’ h â‰¡ âŸ¨ f ,â‚‘ g âŸ©
    Ã—Î·-lemma h p q = (sym Ã—Ì¬Î·) âˆ™ congâ‚‚ (Î» x y â†’ âŸ¨ x ,â‚‘ y âŸ©) p q
  FreeCartesianCategory .âŠ¤ = âŠ¤Ì¬
  FreeCartesianCategory .! = !â‚‘
  FreeCartesianCategory .âŠ¤Î· = âŠ¤Ì¬Î·
  open Interp
  reinterp-trivial : (A : ProdTypeExpr') â†’ interpret-objects Q FreeCartesianCategory â†‘Ì¬ A â‰¡ A
  reinterp-trivial (â†‘Ì¬ B) = refl
  reinterp-trivial (B Ã—Ì¬ C) i = reinterp-trivial B i Ã—Ì¬ reinterp-trivial C i
  reinterp-trivial âŠ¤Ì¬  = refl
  reinterp-trivial' : _
  reinterp-trivial' = funExt reinterp-trivial
  Î· : Interp Q FreeCartesianCategory
  Î· .I-ob = â†‘Ì¬
  Î· .I-hom e = transportâ» inside-EdgeExpr (â†‘â‚‘ e)
    where
    inside-EdgeExpr : âˆ€{A B} â†’ EdgeExpr[ interpret-objects Q FreeCartesianCategory â†‘Ì¬ A , interpret-objects Q FreeCartesianCategory â†‘Ì¬ B ] â‰¡ EdgeExpr[ A , B ]
    inside-EdgeExpr {A} {B} = congS (Î» x â†’ EdgeExpr[ x A , x B ]) reinterp-trivial'
  module _ {ğ“’ : BinaryCartesianCategory â„“c â„“c'}(F : StrictCartesianFunctor FreeCartesianCategory ğ“’) where
  module _ {ğ“’ : BinaryCartesianCategory â„“c â„“c'}(F F' : StrictCartesianFunctor FreeCartesianCategory ğ“’) where
    module _ (agree-on-Î· : {!!}) where
      open import Cubical.Foundations.HLevels
      open import Cubical.Foundations.Path
      open import Cubical.Foundations.Isomorphism

      open Iso
      aoo : âˆ€ t â†’ F .functor âŸ… t âŸ† â‰¡ F' .functor âŸ… t âŸ†
      aoo (â†‘Ì¬ A) i = agree-on-Î· i .I-ob A
      aoo (A Ã—Ì¬ B) = {!!}
      -- F .preserves-Ã— âˆ™ inside-Ã— ğ“’ (aoo A) (aoo B) âˆ™ sym (F' .preserves-Ã—)
      aoo âŠ¤Ì¬ = F .preserves-âŠ¤ âˆ™ sym (F' .preserves-âŠ¤)
      aoo' = funExt aoo
      aom-type : âˆ€{t t'} â†’ (f : FreeCartesianCategory .cat [ t , t' ]) â†’ Type _
      aom-type {t} {t'} f = PathP (Î» i â†’ congS (Î» x â†’ ğ“’ .cat [ x t , x t' ]) aoo' i) (F .functor .F-hom f) (F' .functor .F-hom f)
