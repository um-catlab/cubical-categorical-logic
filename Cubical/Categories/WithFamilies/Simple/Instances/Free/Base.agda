-- Free Simple Category with families generated by base types and function symbols
module Cubical.Categories.WithFamilies.Simple.Instances.Free.Base where

open import Cubical.Foundations.Equiv
open import Cubical.Foundations.Function
open import Cubical.Foundations.HLevels
open import Cubical.Foundations.Isomorphism
open import Cubical.Foundations.Prelude
open import Cubical.Foundations.Structure

open import Cubical.Data.FinData
open import Cubical.Data.List
open import Cubical.Data.List.FinData hiding (ℓ; A; B)
open import Cubical.Data.List.Dependent
open import Cubical.Data.Sigma
open import Cubical.Data.Unit

open import Cubical.Categories.Category.Base
open import Cubical.Categories.Functor
open import Cubical.Categories.Limits.Terminal.More
open import Cubical.Categories.Presheaf
open import Cubical.Categories.Presheaf.Constructions

open import Cubical.Categories.WithFamilies.Simple.Base

private
  variable
    ℓ ℓ' : Level

open Category
open Functor
open UniversalElement

module _ (Σ₀ : hGroupoid ℓ) where
  private
    variable
      Δ Γ Θ Ξ : List ⟨ Σ₀ ⟩
      A B C : ⟨ Σ₀ ⟩
  -- I guess this is equivalent to
  -- Var Γ A = fiber (lookup Γ) A
  data Var : (Γ : List ⟨ Σ₀ ⟩) → ⟨ Σ₀ ⟩ → Type ℓ where
    vz : ∀ {Γ A} → Var (A ∷ Γ) A
    vs : ∀ {Γ A B} → Var Γ A → Var (B ∷ Γ) A

  Var' : (Γ : List ⟨ Σ₀ ⟩) → (A : ⟨ Σ₀ ⟩) → Type ℓ
  Var' Γ = fiber (lookup Γ)

  isSetVar' : isSet (Var' Γ A)
  isSetVar' = isSetΣ isSetFin λ _ → Σ₀ .snd _ _

  isSetVar : isSet (Var Γ A)
  isSetVar {Γ = Γ} = isSetRetract var→var' var'→var (r _ _) (isSetVar' {Γ = Γ}) where
    var→var' : ∀ {Γ A} → Var Γ A → Var' Γ A
    var→var' vz = zero , refl
    var→var' (vs x) = suc (x' .fst) , x' .snd where
      x' = var→var' x

    var'→var : ∀ {Γ A} → Var' Γ A → Var Γ A
    var'→var {A' ∷ Γ}{A} (zero , x':A) =
      subst (λ A' → Var (A' ∷ Γ) A) (sym x':A) vz
    var'→var {A' ∷ Γ}{A} (suc x' , x':A) =
      vs (var'→var (x' , x':A))

    r : ∀ Γ A (x : Var Γ A) → var'→var (var→var' x) ≡ x
    r Γ A vz = transportRefl _
    r Γ A (vs x) = cong vs (r _ _ x)

  Thinning : (Δ : List ⟨ Σ₀ ⟩) (Γ : List ⟨ Σ₀ ⟩) → Type ℓ
  Thinning Δ = ListP (Var Δ)

  ⟨_⟩∷⟨_⟩ :
    ∀ {x x' : Var Δ A}{γ γ' : Thinning Δ Γ}
    → x ≡ x'
    → γ ≡ γ'
    → Path (Thinning Δ (A ∷ Γ)) (x ∷ γ) (x' ∷ γ')
  ⟨ x ⟩∷⟨ γ ⟩ i = x i ∷ γ i

  private
    variable
      γ δ θ : Thinning Δ Γ

  -- Thinnings act on variables
  thin : Thinning Δ Γ → Var Γ A → Var Δ A
  thin (y ∷ γ) vz = y
  thin (y ∷ γ) (vs x) = thin γ x

  wkThin : Thinning Δ Γ → Thinning (A ∷ Δ) Γ
  wkThin [] = []
  wkThin (x ∷ θ) = (vs x) ∷ (wkThin θ)

  idThin : ∀ Γ → Thinning Γ Γ
  idThin [] = []
  idThin (x ∷ Γ) = vz ∷ wkThin (idThin Γ)

  _⋆Thin_ : Thinning Θ Δ → Thinning Δ Γ → Thinning Θ Γ
  δ ⋆Thin [] = []
  δ ⋆Thin (x ∷ γ) = thin δ x ∷ (δ ⋆Thin γ)

  thinWkThin : ∀ (γ : Thinning Δ Γ)(x : Var Γ A)
    → thin (wkThin {A = B} γ) x ≡ vs (thin γ x)
  thinWkThin (y ∷ γ) vz = refl
  thinWkThin (y ∷ γ) (vs x) = thinWkThin γ x

  thinId : ∀ {A} Γ (x : Var Γ A) → thin (idThin Γ) x ≡ x
  thinId (B ∷ Γ) vz = refl
  thinId (B ∷ Γ) (vs x) =
    thinWkThin (idThin Γ) x
    ∙ cong vs (thinId Γ x)

  thin⋆ : ∀ {Θ Δ Γ A}{δ : Thinning Θ Δ}(γ : Thinning Δ Γ)(x : Var Γ A)
    → thin (δ ⋆Thin γ) x ≡ thin δ (thin γ x)
  thin⋆ (y ∷ γ) vz = refl
  thin⋆ (y ∷ γ) (vs x) = thin⋆ γ x

  ⋆Thin⋆IdL : ∀ (γ : Thinning Δ Γ) → (idThin Δ ⋆Thin γ) ≡ γ
  ⋆Thin⋆IdL [] = refl
  ⋆Thin⋆IdL (x ∷ γ) = ⟨ thinId _ x ⟩∷⟨ ⋆Thin⋆IdL γ ⟩

  ⋆ThinWk :
    ∀ (γ : Thinning Δ Γ) (δ : Thinning Θ Δ) (x : Var Θ A) →
    (x ∷ δ) ⋆Thin wkThin γ ≡ (δ ⋆Thin γ)
  ⋆ThinWk [] δ x = refl
  ⋆ThinWk (y ∷ γ) δ x = ⟨ refl ⟩∷⟨ ⋆ThinWk γ δ x ⟩

  ⋆Thin⋆IdR : ∀ Γ (γ : Thinning Δ Γ) → (γ ⋆Thin idThin Γ) ≡ γ
  ⋆Thin⋆IdR [] [] = refl
  ⋆Thin⋆IdR (A ∷ Γ) (x ∷ γ) = ⟨ refl ⟩∷⟨ ⋆ThinWk (idThin _) γ x ∙ ⋆Thin⋆IdR Γ γ ⟩

  ⋆Thin⋆Assoc :
    ∀ (θ : Thinning Ξ Θ)
    → (δ : Thinning Θ Δ)
    → (γ : Thinning Δ Γ)
    → ((θ ⋆Thin δ) ⋆Thin γ) ≡ θ ⋆Thin (δ ⋆Thin γ)
  ⋆Thin⋆Assoc _ _ [] = refl
  ⋆Thin⋆Assoc θ δ (x ∷ γ) = ⟨ thin⋆ δ x ⟩∷⟨ ⋆Thin⋆Assoc _ _ _ ⟩

  ThinningCategory : Category ℓ ℓ
  ThinningCategory .ob = List ⟨ Σ₀ ⟩
  ThinningCategory .Hom[_,_] = Thinning
  ThinningCategory .id = idThin _
  ThinningCategory ._⋆_ = _⋆Thin_
  ThinningCategory .⋆IdL = ⋆Thin⋆IdL
  ThinningCategory .⋆IdR = ⋆Thin⋆IdR _
  ThinningCategory .⋆Assoc = ⋆Thin⋆Assoc
  ThinningCategory .isSetHom = isOfHLevelSucSuc-ListP 0 λ _ → isSetVar

  ThinPsh : ∀ (A : ⟨ Σ₀ ⟩) → Presheaf ThinningCategory ℓ
  ThinPsh A .F-ob Γ .fst = Var Γ A
  ThinPsh A .F-ob Γ .snd = isSetVar
  ThinPsh A .F-hom = thin
  ThinPsh A .F-id = funExt (thinId _)
  ThinPsh A .F-seq γ δ = funExt (thin⋆ γ)

  TermCtx : Terminal' ThinningCategory
  TermCtx .vertex = []
  TermCtx .element = tt
  TermCtx .universal Γ = isIsoToIsEquiv
    ((λ z → []) , ((λ _ → refl) , (λ { [] → refl })))

  CtxExt : ∀ A → LocallyRepresentable (ThinPsh A)
  CtxExt A Γ .vertex = A ∷ Γ
  CtxExt A Γ .element = (wkThin $ idThin _) , vz
  CtxExt A Γ .universal Δ = isIsoToIsEquiv
    ( (λ γx → (γx .snd) ∷ (γx .fst))
    , (λ γx → ΣPathP ((⋆ThinWk _ _ _ ∙ ⋆Thin⋆IdR _ _) , refl))
    , λ { (x ∷ γ) → ⟨ refl ⟩∷⟨ ⋆ThinWk _ _ _ ∙ ⋆Thin⋆IdR _ _ ⟩ })

  FreeSCwF : SCwF ℓ ℓ ℓ ℓ
  FreeSCwF .fst = ThinningCategory
  FreeSCwF .snd .fst = ⟨ Σ₀ ⟩
  FreeSCwF .snd .snd .fst = ThinPsh
  FreeSCwF .snd .snd .snd .fst = TermCtx
  FreeSCwF .snd .snd .snd .snd Γ A = CtxExt A Γ

  -- TODO: prove that it's Free
