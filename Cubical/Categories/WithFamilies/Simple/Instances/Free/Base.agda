{-# OPTIONS -WnoUnsupportedIndexedMatch #-}
{-# OPTIONS --lossy-unification #-}
-- Free Simple Category with families generated by base types and function symbols
module Cubical.Categories.WithFamilies.Simple.Instances.Free.Base where

open import Cubical.Foundations.Equiv
open import Cubical.Foundations.Function
open import Cubical.Foundations.HLevels
open import Cubical.Foundations.Isomorphism
open import Cubical.Foundations.Prelude
open import Cubical.Foundations.Structure
open import Cubical.Foundations.More

open import Cubical.Data.FinData hiding (elim)
open import Cubical.Data.List hiding (elim; [_])
open import Cubical.Data.List.FinData hiding (ℓ; A; B)
open import Cubical.Data.List.Dependent
open import Cubical.Data.Sigma
open import Cubical.Data.Unit

open import Cubical.Categories.Category.Base
open import Cubical.Categories.Constructions.Fiber hiding (fiber)
open import Cubical.Categories.Constructions.TotalCategory using (∫C)
open import Cubical.Categories.Functor
open import Cubical.Categories.Limits.Terminal.More
open import Cubical.Categories.Presheaf
open import Cubical.Categories.Presheaf.Constructions
open import Cubical.Categories.Presheaf.More

open import Cubical.Categories.Displayed.Base
open import Cubical.Categories.Displayed.Functor
open import Cubical.Categories.Displayed.Section
open import Cubical.Categories.Displayed.Presheaf

open import Cubical.Categories.WithFamilies.Simple.Base
open import Cubical.Categories.WithFamilies.Simple.Displayed
open import Cubical.Categories.WithFamilies.Simple.Properties

private
  variable
    ℓ ℓ' ℓC ℓC' ℓT ℓT' : Level

open Category
open Functor
open Functorᴰ
open Section
open UniversalElement

module _ (Σ₀ : hGroupoid ℓ) where
  private
    variable
      Δ Γ Θ Ξ : List ⟨ Σ₀ ⟩
      A B C : ⟨ Σ₀ ⟩
  -- I guess this is equivalent to
  -- Var Γ A = fiber (lookup Γ) A
  data Var : (Γ : List ⟨ Σ₀ ⟩) → ⟨ Σ₀ ⟩ → Type ℓ where
    vz : ∀ {Γ A} → Var (A ∷ Γ) A
    vs : ∀ {Γ A B} → Var Γ A → Var (B ∷ Γ) A

  Var' : (Γ : List ⟨ Σ₀ ⟩) → (A : ⟨ Σ₀ ⟩) → Type ℓ
  Var' Γ = fiber (lookup Γ)

  isSetVar' : isSet (Var' Γ A)
  isSetVar' = isSetΣ isSetFin λ _ → Σ₀ .snd _ _

  isSetVar : isSet (Var Γ A)
  isSetVar {Γ = Γ} = isSetRetract var→var' var'→var (r _ _) (isSetVar' {Γ = Γ}) where
    var→var' : ∀ {Γ A} → Var Γ A → Var' Γ A
    var→var' vz = zero , refl
    var→var' (vs x) = suc (x' .fst) , x' .snd where
      x' = var→var' x

    var'→var : ∀ {Γ A} → Var' Γ A → Var Γ A
    var'→var {A' ∷ Γ}{A} (zero , x':A) =
      subst (λ A' → Var (A' ∷ Γ) A) (sym x':A) vz
    var'→var {A' ∷ Γ}{A} (suc x' , x':A) =
      vs (var'→var (x' , x':A))

    r : ∀ Γ A (x : Var Γ A) → var'→var (var→var' x) ≡ x
    r Γ A vz = transportRefl _
    r Γ A (vs x) = cong vs (r _ _ x)

  Renaming : (Δ : List ⟨ Σ₀ ⟩) (Γ : List ⟨ Σ₀ ⟩) → Type ℓ
  Renaming Δ = ListP (Var Δ)

  ⟨_⟩∷⟨_⟩ :
    ∀ {x x' : Var Δ A}{γ γ' : Renaming Δ Γ}
    → x ≡ x'
    → γ ≡ γ'
    → Path (Renaming Δ (A ∷ Γ)) (x ∷ γ) (x' ∷ γ')
  ⟨ x ⟩∷⟨ γ ⟩ i = x i ∷ γ i

  private
    variable
      γ δ θ : Renaming Δ Γ

  -- Renamings act on variables
  ren : Renaming Δ Γ → Var Γ A → Var Δ A
  ren (y ∷ γ) vz = y
  ren (y ∷ γ) (vs x) = ren γ x

  wkRen : Renaming Δ Γ → Renaming (A ∷ Δ) Γ
  wkRen [] = []
  wkRen (x ∷ θ) = (vs x) ∷ (wkRen θ)

  idRen : ∀ Γ → Renaming Γ Γ
  idRen [] = []
  idRen (x ∷ Γ) = vz ∷ wkRen (idRen Γ)

  _⋆Ren_ : Renaming Θ Δ → Renaming Δ Γ → Renaming Θ Γ
  δ ⋆Ren [] = []
  δ ⋆Ren (x ∷ γ) = ren δ x ∷ (δ ⋆Ren γ)

  renWkRen : ∀ (γ : Renaming Δ Γ)(x : Var Γ A)
    → ren (wkRen {A = B} γ) x ≡ vs (ren γ x)
  renWkRen (y ∷ γ) vz = refl
  renWkRen (y ∷ γ) (vs x) = renWkRen γ x

  renId : ∀ {A} Γ (x : Var Γ A) → ren (idRen Γ) x ≡ x
  renId (B ∷ Γ) vz = refl
  renId (B ∷ Γ) (vs x) =
    renWkRen (idRen Γ) x
    ∙ cong vs (renId Γ x)

  ren⋆ : ∀ {Θ Δ Γ A}{δ : Renaming Θ Δ}(γ : Renaming Δ Γ)(x : Var Γ A)
    → ren (δ ⋆Ren γ) x ≡ ren δ (ren γ x)
  ren⋆ (y ∷ γ) vz = refl
  ren⋆ (y ∷ γ) (vs x) = ren⋆ γ x

  ⋆Ren⋆IdL : ∀ (γ : Renaming Δ Γ) → (idRen Δ ⋆Ren γ) ≡ γ
  ⋆Ren⋆IdL [] = refl
  ⋆Ren⋆IdL (x ∷ γ) = ⟨ renId _ x ⟩∷⟨ ⋆Ren⋆IdL γ ⟩

  ⋆RenWk :
    ∀ (γ : Renaming Δ Γ) (δ : Renaming Θ Δ) (x : Var Θ A) →
    (x ∷ δ) ⋆Ren wkRen γ ≡ (δ ⋆Ren γ)
  ⋆RenWk [] δ x = refl
  ⋆RenWk (y ∷ γ) δ x = ⟨ refl ⟩∷⟨ ⋆RenWk γ δ x ⟩

  ⋆Ren⋆IdR : ∀ Γ (γ : Renaming Δ Γ) → (γ ⋆Ren idRen Γ) ≡ γ
  ⋆Ren⋆IdR [] [] = refl
  ⋆Ren⋆IdR (A ∷ Γ) (x ∷ γ) = ⟨ refl ⟩∷⟨ ⋆RenWk (idRen _) γ x ∙ ⋆Ren⋆IdR Γ γ ⟩

  ⋆Ren⋆Assoc :
    ∀ (θ : Renaming Ξ Θ)
    → (δ : Renaming Θ Δ)
    → (γ : Renaming Δ Γ)
    → ((θ ⋆Ren δ) ⋆Ren γ) ≡ θ ⋆Ren (δ ⋆Ren γ)
  ⋆Ren⋆Assoc _ _ [] = refl
  ⋆Ren⋆Assoc θ δ (x ∷ γ) = ⟨ ren⋆ δ x ⟩∷⟨ ⋆Ren⋆Assoc _ _ _ ⟩

  RenamingCategory : Category ℓ ℓ
  RenamingCategory .ob = List ⟨ Σ₀ ⟩
  RenamingCategory .Hom[_,_] = Renaming
  RenamingCategory .id = idRen _
  RenamingCategory ._⋆_ = _⋆Ren_
  RenamingCategory .⋆IdL = ⋆Ren⋆IdL
  RenamingCategory .⋆IdR = ⋆Ren⋆IdR _
  RenamingCategory .⋆Assoc = ⋆Ren⋆Assoc
  RenamingCategory .isSetHom = isOfHLevelSucSuc-ListP 0 λ _ → isSetVar

  RenPsh : ∀ (A : ⟨ Σ₀ ⟩) → Presheaf RenamingCategory ℓ
  RenPsh A .F-ob Γ .fst = Var Γ A
  RenPsh A .F-ob Γ .snd = isSetVar
  RenPsh A .F-hom = ren
  RenPsh A .F-id = funExt (renId _)
  RenPsh A .F-seq γ δ = funExt (ren⋆ γ)

  TermCtx : Terminal' RenamingCategory
  TermCtx .vertex = []
  TermCtx .element = tt
  TermCtx .universal Γ = isIsoToIsEquiv
    ((λ z → []) , ((λ _ → refl) , (λ { [] → refl })))

  CtxExt : ∀ A → LocallyRepresentable (RenPsh A)
  CtxExt A Γ .vertex = A ∷ Γ
  CtxExt A Γ .element = (wkRen $ idRen _) , vz
  CtxExt A Γ .universal Δ = isIsoToIsEquiv
    ( (λ γx → (γx .snd) ∷ (γx .fst))
    , (λ γx → ΣPathP ((⋆RenWk _ _ _ ∙ ⋆Ren⋆IdR _ _) , refl))
    , λ { (x ∷ γ) → ⟨ refl ⟩∷⟨ ⋆RenWk _ _ _ ∙ ⋆Ren⋆IdR _ _ ⟩ })

  FreeSCwF : SCwF ℓ ℓ ℓ ℓ
  FreeSCwF .fst = RenamingCategory
  FreeSCwF .snd .fst = ⟨ Σ₀ ⟩
  FreeSCwF .snd .snd .fst = RenPsh
  FreeSCwF .snd .snd .snd .fst = TermCtx
  FreeSCwF .snd .snd .snd .snd = CtxExt

  module _ (M : SCwFᴰ FreeSCwF ℓC ℓC' ℓT ℓT') where
    private
      Cᴰ = M .fst
      module Cᴰ = Fibers Cᴰ
      ∫Cᴰ = ∫C Cᴰ
      Tyᴰ = M .snd .fst
      Tmᴰ = M .snd .snd .fst
      module ∫Tmᴰ {A}{Aᴰ : Tyᴰ A} = PresheafNotation (∫P (Tmᴰ Aᴰ))
      module Tmᴰ {A}{Aᴰ : Tyᴰ A} = PresheafᴰNotation (Tmᴰ Aᴰ)
      termᴰ = M .snd .snd .snd .fst
      extᴰ  = M .snd .snd .snd .snd
      module M = SCwFᴰNotation M
    open UniversalElementᴰ
    open PshHomᴰ
    module _ (ı : ∀ A → Tyᴰ A) where
      elimS-F-ob : ∀ Γ → Cᴰ.ob[ Γ ]
      elimS-F-ob [] = vertexᴰ termᴰ
      elimS-F-ob (A ∷ Γ) = vertexᴰ (extᴰ (ı A) (elimS-F-ob Γ))

      elimVar : ∀ {Γ A} (x : Var Γ A) → ⟨ Tmᴰ (ı A) .F-obᴰ (elimS-F-ob Γ) x ⟩
      elimVar {Γ = A ∷ Γ}{A = A} vz = extᴰ (ı A) (elimS-F-ob Γ) .elementᴰ .snd
      -- x:B ∈ Γ
      -- ------------- vs
      -- x:B ∈ (A ∷ Γ)
      elimVar (vs x) =
        Tmᴰ.reind lemma
          $ (extᴰ (ı _) (elimS-F-ob _) .elementᴰ .fst) Tmᴰ.⋆ᴰ elimVar x
        where
          lemma : ∀ {B} → ren (wkRen {A = B} $ idRen _) x ≡ vs x
          lemma = renWkRen (idRen _) x ∙ cong vs (renId _ _)

      elimRen : ∀ {Δ Γ} (γ : Renaming Δ Γ) → Cᴰ [ γ ][ elimS-F-ob Δ , elimS-F-ob Γ ]
      elimRen [] = introᴰ termᴰ _
      elimRen (x ∷ γ) = introᴰ (extᴰ _ _) (elimRen γ , elimVar x)

      elimRenWkRen : ∀ {Δ Γ A}(γ : Renaming Δ Γ)
        → Path (∫Cᴰ [ (A ∷ Δ , _) , (Γ , _) ])
            (_ , elimRen (wkRen γ))
            (_ , extᴰ _ _ .elementᴰ .fst Cᴰ.⋆ᴰ elimRen γ)
      elimRenWkRen [] = extensionalityᴰ termᴰ refl
      elimRenWkRen (x ∷ γ) =
        introᴰ≡ (extᴰ _ _) (ΣPathPᴰ (elimRenWkRen γ ∙ Cᴰ.⟨ refl ⟩⋆⟨ sym $ PathPᴰΣ (βᴰ $ extᴰ _ _) .fst ⟩ ∙ sym (Cᴰ.⋆Assoc _ _ _))
                           (((sym $ Tmᴰ.reind-filler _ _) ∙ Tmᴰ.⟨⟩⋆⟨ sym $ PathPᴰΣ (βᴰ $ extᴰ _ _) .snd ⟩) ∙ sym (Tmᴰ.⋆Assoc _ _ _)))

      elimRen-Var : ∀ {Δ Γ A}
        → (γ : Renaming Δ Γ)
        → (x : Var Γ A)
        → Path ∫Tmᴰ.p[ _ ]
            (_ , elimVar (ren γ x))
            (_ , elimRen γ Tmᴰ.⋆ᴰ elimVar x)
      elimRen-Var (y ∷ γ) vz = sym $ PathPᴰΣ (βᴰ $ extᴰ _ _) .snd
      elimRen-Var (y ∷ γ) (vs x) =
        elimRen-Var γ x
        ∙ Tmᴰ.⟨ sym $ PathPᴰΣ (βᴰ $ extᴰ _ _) .fst ⟩⋆⟨⟩
        ∙ Tmᴰ.⋆Assoc _ _ _
        ∙ Tmᴰ.⟨⟩⋆⟨ Tmᴰ.reind-filler _ _ ⟩

      elimRen-Id : ∀ Γ →
        Path (∫Cᴰ [ _ , _ ])
          (_ , elimRen (idRen Γ))
          (_ , Cᴰ.idᴰ)
      elimRen-Id [] = extensionalityᴰ termᴰ refl
      elimRen-Id (x ∷ Γ) =
        introᴰ≡ (extᴰ _ _)
          (ΣPathPᴰ
            (elimRenWkRen _ ∙ Cᴰ.⟨ refl ⟩⋆⟨ elimRen-Id Γ ⟩ ∙ Cᴰ.⋆IdR _ ∙ sym (Cᴰ.⋆IdL _))
            (sym $ Tmᴰ.⋆IdL _))

      elimRen-Seq : ∀ {Θ Δ Γ}
        → {δ : Renaming Θ Δ}
        → (γ : Renaming Δ Γ)
        → Path (∫Cᴰ [ _ , _ ])
            (_ , elimRen (δ ⋆Ren γ))
            (_ , elimRen δ Cᴰ.⋆ᴰ elimRen γ)
      elimRen-Seq [] = extensionalityᴰ termᴰ refl
      elimRen-Seq (y ∷ γ) = introᴰ≡ (extᴰ _ _) (ΣPathPᴰ
        (elimRen-Seq γ ∙ Cᴰ.⟨ refl ⟩⋆⟨ sym $ PathPᴰΣ (βᴰ $ extᴰ _ _) .fst ⟩ ∙ sym (Cᴰ.⋆Assoc _ _ _))
        (elimRen-Var _ _ ∙ Tmᴰ.⟨⟩⋆⟨ sym $ PathPᴰΣ (βᴰ $ extᴰ _ _) .snd ⟩ ∙ sym (Tmᴰ.⋆Assoc _ _ _)))

      elimSection : GlobalSection (M .fst)
      elimSection .F-obᴰ = elimS-F-ob
      elimSection .F-homᴰ = elimRen
      elimSection .F-idᴰ = Cᴰ.rectify $ Cᴰ.≡out $ elimRen-Id _
      elimSection .F-seqᴰ δ γ = Cᴰ.rectify $ Cᴰ.≡out $ elimRen-Seq γ

      elimPshSection : ∀ {A} → PshSection elimSection (Tmᴰ $ ı A)
      elimPshSection .N-obᴰ {Γ}{_}{x} _ = elimVar x
      elimPshSection {A} .N-homᴰ {Δ} {Γ} {_} {_} {γ} {x} =
        Tmᴰ.rectify $ Tmᴰ.≡out $ elimRen-Var _ _

      elim : StrictSection FreeSCwF M
      elim .fst = elimSection
      elim .snd .fst = ı
      elim .snd .snd .fst = λ _ → elimPshSection
      elim .snd .snd .snd .fst = refl
      elim .snd .snd .snd .snd A Γ = ΣPathP (refl , (ΣPathP ((Cᴰ.rectify $ Cᴰ.≡out $ elimRenWkRen _ ∙ Cᴰ.⟨ refl ⟩⋆⟨ elimRen-Id _ ⟩ ∙ Cᴰ.⋆IdR _) , refl)))
