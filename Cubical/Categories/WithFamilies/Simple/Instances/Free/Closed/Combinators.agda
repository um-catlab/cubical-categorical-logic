{-# OPTIONS --lossy-unification #-}
-- Free Simple Category with families generated by a groupoid of base types
module Cubical.Categories.WithFamilies.Simple.Instances.Free.Closed.Combinators where

open import Cubical.Foundations.Equiv
open import Cubical.Foundations.Function
open import Cubical.Foundations.HLevels
open import Cubical.Foundations.Isomorphism
open import Cubical.Foundations.Prelude
open import Cubical.Foundations.Structure
open import Cubical.Foundations.More

open import Cubical.Data.FinData hiding (elim)
open import Cubical.Data.List hiding (elim; [_])
open import Cubical.Data.List.FinData
open import Cubical.Data.List.Dependent
open import Cubical.Data.Sigma
open import Cubical.Data.Unit
import Cubical.Data.Equality as Eq

open import Cubical.Categories.Category.Base
open import Cubical.Categories.Constructions.Fiber hiding (fiber)
open import Cubical.Categories.Constructions.TotalCategory using (∫C)
open import Cubical.Categories.Functor
open import Cubical.Categories.Limits.Terminal.More
open import Cubical.Categories.Presheaf hiding (L)
open import Cubical.Categories.Presheaf.Constructions
open import Cubical.Categories.Presheaf.More
open import Cubical.Categories.Presheaf.Morphism.Alt

open import Cubical.Categories.Displayed.Base
open import Cubical.Categories.Displayed.Functor
open import Cubical.Categories.Displayed.Section
open import Cubical.Categories.Displayed.Presheaf

open import Cubical.Categories.WithFamilies.Simple.Base
open import Cubical.Categories.WithFamilies.Simple.Displayed
open import Cubical.Categories.WithFamilies.Simple.TypeStructure.Functions

private
  variable
    ℓ ℓ' ℓC ℓC' ℓT ℓT' : Level

open Category
open Functor
open UniversalElement

module _ (Σ₀ : Type ℓ) where
  data ⇒Ty : Type ℓ where
    gen : Σ₀ → ⇒Ty
    _⇒_ : ⇒Ty → ⇒Ty → ⇒Ty

  Ctx = List ⇒Ty
  module _ (Σ₁ : Ctx → ⇒Ty → Type ℓ') where
    -- subst is a free category with comprehension
    data Subst : (Δ : Ctx) (Γ : Ctx) → Type (ℓ-max ℓ ℓ')
    data Term : (Γ : Ctx)(A : ⇒Ty) → Type (ℓ-max ℓ ℓ')
    private
      variable
        Ξ Θ Δ Γ : Ctx
        A B C : ⇒Ty
        L M N : Term Γ A
        γ δ θ : Subst Δ Γ
    _⋆ₑ'_ : (δ : Subst Γ Δ)(M : Term Δ A) → Term Γ A
    vz' : Term (A ∷ Γ) A

    data Subst where
      -- category
      idₑ : Subst Γ Γ
      _⋆ₑ_ : (δ : Subst Θ Δ) (γ : Subst Δ Γ) → Subst Θ Γ
      ⋆IdLₑ : (γ : Subst Δ Γ) → (idₑ ⋆ₑ γ) ≡ γ
      ⋆IdRₑ : (γ : Subst Δ Γ) → (γ ⋆ₑ idₑ) ≡ γ
      ⋆Assocₑ : (θ : Subst Ξ Θ) (δ : Subst Θ Δ) (γ : Subst Δ Γ) → ((θ ⋆ₑ δ) ⋆ₑ γ) ≡ (θ ⋆ₑ (δ ⋆ₑ γ))
      isSetSubst : isSet (Subst Δ Γ)


      -- terminal object
      [] : Subst Γ []
      []η : ([]' : Subst Γ []) → []' ≡ []

      -- comprehension
      _∷_ : (M : Term Γ A) (δ : Subst Γ Δ) → Subst Γ (A ∷ Δ)
      wk : Subst (A ∷ Γ) Γ
      wkβ : (M ∷ γ) ⋆ₑ wk ≡ γ
      ∷η : {γ : Subst Δ (A ∷ Γ)} → γ ≡ ((γ ⋆ₑ' vz') ∷ (γ ⋆ₑ wk))

    data Term where
      -- generator
      fun : ∀ {Δ A} → Subst Γ Δ → Σ₁ Δ A → Term Γ A

      -- presheaf
      _⋆ₑ_ : (δ : Subst Γ Δ)(M : Term Δ A) → Term Γ A
      -- todo laws
      isSetTerm : isSet (Term Γ A)
      ⋆IdLₑ : (M : Term Γ A) → idₑ ⋆ₑ M ≡ M
      ⋆Assocₑ : (δ : Subst Θ Δ) (γ : Subst Δ Γ)(M : Term Γ A) → ((δ ⋆ₑ γ) ⋆ₑ M) ≡ (δ ⋆ₑ (γ ⋆ₑ M))

      -- comprehension
      vz : Term (A ∷ Γ) A
      vzβ : (M ∷ γ) ⋆ₑ vz ≡ M
      
      -- closed
      λₑ : Term (A ∷ Γ) B → Term Γ (A ⇒ B)
      app : Term (A ∷ (A ⇒ B) ∷ []) B
      
      ⇒β : ((vz ∷ (wk ⋆ₑ (λₑ M ∷ []))) ⋆ₑ app) ≡ M
      ⇒η : M ≡ λₑ ((vz ∷ (wk ⋆ₑ (M ∷ []))) ⋆ₑ app)
    _⋆ₑ'_ = _⋆ₑ_
    vz' = vz

    SubstCat : Category ℓ (ℓ-max ℓ ℓ')
    SubstCat .ob = Ctx
    SubstCat .Hom[_,_] = Subst
    SubstCat .id = idₑ
    SubstCat ._⋆_ = _⋆ₑ_
    SubstCat .⋆IdL = ⋆IdLₑ
    SubstCat .⋆IdR = ⋆IdRₑ
    SubstCat .⋆Assoc = ⋆Assocₑ
    SubstCat .isSetHom = isSetSubst

    TerminalSubst : Terminal' SubstCat
    TerminalSubst .vertex = []
    TerminalSubst .element = tt
    TerminalSubst .universal Γ = isIsoToIsEquiv
      ( (λ z → [])
      , (λ _ → refl)
      , (λ _ → sym $ []η _))

    TermPsh : (A : ⇒Ty) → Presheaf SubstCat (ℓ-max ℓ ℓ')
    TermPsh A .F-ob Γ = (Term Γ A) , isSetTerm
    TermPsh A .F-hom γ M = γ ⋆ₑ M
    TermPsh A .F-id = funExt ⋆IdLₑ
    TermPsh A .F-seq δ γ = funExt (⋆Assocₑ γ δ)

    ComprehensionSubst : (A : ⇒Ty) → LocallyRepresentable (TermPsh A)
    ComprehensionSubst A Γ .vertex = A ∷ Γ
    ComprehensionSubst A Γ .element = wk , vz
    ComprehensionSubst A Γ .universal Δ = isIsoToIsEquiv
      ( (λ γ → γ .snd ∷ γ .fst)
      , (λ γ → ΣPathP (wkβ , vzβ))
      , λ γ → sym ∷η
      )

    TermSCwF : SCwF ℓ (ℓ-max ℓ ℓ') ℓ (ℓ-max ℓ ℓ')
    TermSCwF .SCwF.C = SubstCat
    TermSCwF .SCwF.Ty = ⇒Ty
    TermSCwF .SCwF.Tm = TermPsh
    TermSCwF .SCwF.term = TerminalSubst
    TermSCwF .SCwF.comprehension = ComprehensionSubst

    FunTypesUMP : FunTypes TermSCwF
    FunTypesUMP A B .fst = A ⇒ B
    FunTypesUMP A B .snd .fst = app
    FunTypesUMP A B .snd .snd Γ .fst = λₑ
    FunTypesUMP A B .snd .snd Γ .snd .fst _ = ⇒β
    FunTypesUMP A B .snd .snd Γ .snd .snd _ = sym ⇒η
