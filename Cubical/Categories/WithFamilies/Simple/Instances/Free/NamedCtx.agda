{-# OPTIONS --lossy-unification #-}

-- Free Simple Category with families generated by base types, using a
-- named representation of contexts
module Cubical.Categories.WithFamilies.Simple.Instances.Free.NamedCtx where

open import Cubical.Foundations.Equiv
open import Cubical.Foundations.Function
open import Cubical.Foundations.HLevels
open import Cubical.Foundations.Isomorphism
open import Cubical.Foundations.Prelude
open import Cubical.Foundations.Structure
open import Cubical.Foundations.More

open import Cubical.Data.Empty as ⊥ hiding (elim)
open import Cubical.Data.FinSet
open import Cubical.Data.FinSet.Constructors
open import Cubical.Data.Nat hiding (elim)
open import Cubical.Data.Sigma
open import Cubical.Data.Sum as ⊎ hiding (elim)
open import Cubical.Data.SumFin as Fin hiding (elim)
open import Cubical.Data.Unit

open import Cubical.Categories.Category.Base
open import Cubical.Categories.Constructions.Fiber hiding (fiber)
open import Cubical.Categories.Constructions.TotalCategory using (∫C)
open import Cubical.Categories.Functor
open import Cubical.Categories.Instances.Sets
open import Cubical.Categories.Limits.Terminal.More
open import Cubical.Categories.Presheaf
open import Cubical.Categories.Presheaf.Constructions
open import Cubical.Categories.Presheaf.More

open import Cubical.Categories.Displayed.Base
open import Cubical.Categories.Displayed.Constructions.StructureOver
open import Cubical.Categories.Displayed.Functor
open import Cubical.Categories.Displayed.Fibration.IsoFibration
open import Cubical.Categories.Displayed.Section
open import Cubical.Categories.Displayed.Presheaf

open import Cubical.Categories.WithFamilies.Simple.Base
open import Cubical.Categories.WithFamilies.Simple.Displayed
open import Cubical.Categories.WithFamilies.Simple.Properties

private
  variable
    ℓ ℓ' ℓC ℓC' ℓT ℓT' : Level

open Category
open Functor
open Functorᴰ
open Section
open UniversalElement

module _ (Σ₀ : hSet ℓ) where
  -- This is a category of "ordered sets of variable names", and arbitrary functions
  FinOrdCat : Category (ℓ-suc ℓ-zero) ℓ-zero
  FinOrdCat .ob = Σ[ X ∈ Type ℓ-zero ] isFinOrd X
  FinOrdCat .Hom[_,_] A B = ⟨ A ⟩ → ⟨ B ⟩
  FinOrdCat .id = λ z → z
  FinOrdCat ._⋆_ = λ f g z₁ → g (f z₁)
  FinOrdCat .⋆IdL = λ _ → refl
  FinOrdCat .⋆IdR = λ _ → refl
  FinOrdCat .⋆Assoc = λ _ _ _ → refl
  FinOrdCat .isSetHom {_}{B} = isSet→ (isFinSet→isSet (isFinOrd→isFinSet (B .snd)))

  -- Γ is a finOrd set with a function typeOf : ⟨ Γ ⟩ → Σ₀
  -- a renaming is a renaming of the variables that respects the typing
  RenamingCategory : Category (ℓ-max (ℓ-suc ℓ-zero) ℓ) (ℓ-max ℓ-zero ℓ)
  RenamingCategory = ∫C (StructureOver→Catᴰ RenamingStr)
    where
      open StructureOver
      RenamingStr : StructureOver (FinOrdCat ^op) _ _
      RenamingStr .ob[_] Γ = ⟨ Γ ⟩ → ⟨ Σ₀ ⟩
      RenamingStr .Hom[_][_,_] {Δ}{Γ} γ tyΔ tyΓ =
        ∀ (x : ⟨ Γ ⟩) → tyΓ x ≡ tyΔ (γ x)
      RenamingStr .idᴰ = λ _ → refl
      RenamingStr ._⋆ᴰ_ {δ}{γ} tyδ tyγ x = tyγ x ∙ tyδ _
      RenamingStr .isPropHomᴰ {Δ}{Γ}{γ}{tyΔ} {tyΓ} = isPropΠ λ x → Σ₀ .snd _ _

  private
    module RenCat = Category
  Ctx = RenamingCategory .ob
  Renaming : Ctx → Ctx → Type _
  Renaming Δ Γ = RenamingCategory [ Δ , Γ ]

  TermCtx : Terminal' RenamingCategory
  TermCtx .vertex .fst .fst = ⊥
  TermCtx .vertex .fst .snd = isFinOrd⊥
  TermCtx .vertex .snd = ⊥.rec
  TermCtx .element = tt
  TermCtx .universal Γ = isIsoToIsEquiv (
    (λ _ → (⊥.rec , ⊥.elim))
    , (λ _ → refl)
    , λ (γ , tyγ) → ΣPathP ((funExt ⊥.elim) , (funExt ⊥.elim)))

  Var : Ctx → ⟨ Σ₀ ⟩ → Type _
  Var Γ A = fiber (Γ .snd) A

  VarPsh : ⟨ Σ₀ ⟩ → Presheaf RenamingCategory _
  VarPsh A .F-ob Γ .fst = Var Γ A
  VarPsh A .F-ob Γ .snd =
    isSetΣ (isFinSet→isSet (isFinOrd→isFinSet (Γ .fst .snd)))
           (λ x → isProp→isSet (Σ₀ .snd _ _))
  VarPsh A .F-hom (γ , tyγ) (x , x:A) = γ x , (sym $ tyγ x) ∙ x:A
  VarPsh A .F-id = funExt λ x → Σ≡Prop (λ _ → Σ₀ .snd _ _) refl
  VarPsh A .F-seq γ δ = funExt λ x → Σ≡Prop ((λ _ → Σ₀ .snd _ _)) refl

  CtxExt : ∀ A → LocallyRepresentable (VarPsh A)
  CtxExt A Γ .vertex .fst .fst = Γ .fst .fst ⊎ Unit
  CtxExt A Γ .vertex .fst .snd = isFinOrd⊎ _ (Γ .fst .snd) _ isFinOrdUnit
  CtxExt A Γ .vertex .snd = ⊎.rec (Γ .snd) λ _ → A
  CtxExt A Γ .element .fst .fst = inl
  CtxExt A Γ .element .fst .snd = λ _ → refl
  CtxExt A Γ .element .snd .fst = inr tt
  CtxExt A Γ .element .snd .snd = refl
  CtxExt A Γ .universal Δ = isIsoToIsEquiv
    ( (λ γ,x → ⊎.rec (λ y → γ,x .fst .fst y) (λ _ → γ,x .snd .fst) , (⊎.elim (γ,x .fst .snd) λ _ → sym $ γ,x .snd .snd))
    , (λ γ,x → ΣPathP (Σ≡Prop (λ _ → isPropΠ λ x → Σ₀ .snd _ _) refl
                     , Σ≡Prop (λ _ → Σ₀ .snd _ _) refl))
    , λ γx → Σ≡Prop ((λ _ → isPropΠ λ x → Σ₀ .snd _ _)) (funExt (⊎.elim
        (λ y → refl)
        (λ _ → refl)))
    )

  FreeSCwF : SCwF (ℓ-max (ℓ-suc ℓ-zero) ℓ) (ℓ-max ℓ-zero ℓ) ℓ ℓ
  FreeSCwF .fst = RenamingCategory
  FreeSCwF .snd .fst = ⟨ Σ₀ ⟩
  FreeSCwF .snd .snd .fst = VarPsh
  FreeSCwF .snd .snd .snd .fst = TermCtx
  FreeSCwF .snd .snd .snd .snd = CtxExt

  module _ (M : SCwFᴰ FreeSCwF ℓC ℓC' ℓT ℓT') where
    open SCwFᴰNotation M
    module _ (isoFib : isIsoFibration Cᴰ) (ı : ∀ A → Tyᴰ A) where
      -- I either need univalence or that M.Cᴰ is an isofibration here.
      elimS-F-ob' :
        ∀ (⟨Γ⟩ : Type ℓ-zero) n (Γ≡Finn : ⟨Γ⟩ ≃ Fin n)(tyΓ : ⟨Γ⟩ → ⟨ Σ₀ ⟩)
        → Cᴰ.ob[ (⟨Γ⟩ , n , Γ≡Finn) , tyΓ ]
      -- In theory, we want to use M.termᴰ, but M.termᴰ
      elimS-F-ob' ⟨Γ⟩ zero Γ≡Finn tyΓ = {!termᴰ.vertexᴰ!}
      elimS-F-ob' ⟨Γ⟩ (suc n) Γ≡Finn tyΓ = {!!}

      elimS-F-ob : ∀ Γ → Cᴰ.ob[ Γ ]
      elimS-F-ob Γ =
        elimS-F-ob' (Γ .fst .fst) (Γ .fst .snd .fst) (Γ .fst .snd .snd) (Γ .snd)

      elimVar : ∀ {Γ A} (x : Var Γ A) → ⟨ Tmᴰ (ı A) .F-obᴰ (elimS-F-ob Γ) x ⟩
      elimRen : ∀ {Δ Γ} (γ : Renaming Δ Γ) → Cᴰ [ γ ][ elimS-F-ob Δ , elimS-F-ob Γ ]

      elimSection : GlobalSection (M .fst)
      elimSection .F-obᴰ Γ = elimS-F-ob Γ
      elimSection .F-homᴰ = {!!}
      elimSection .F-idᴰ = {!!}
      elimSection .F-seqᴰ = {!!}
      
      elimPshSection : ∀ {A} → PshSection elimSection (Tmᴰ $ ı A)
      elimPshSection = {!!}
      elim : StrictSection FreeSCwF M
      elim .fst = elimSection
      elim .snd .fst = ı
      elim .snd .snd .fst = λ A → elimPshSection
      elim .snd .snd .snd .fst = {!!}
      elim .snd .snd .snd .snd = {!!}
