{-

  The syntax of simply typed terms generated by base types and
  function types along with its universal property as the initial
  closed simple category with families.

-}
{-# OPTIONS --safe #-}
module Syntax.FreeClosedSCwF where

open import Cubical.Foundations.Prelude
open import Cubical.Foundations.Equiv
open import Cubical.Foundations.HLevels
open import Cubical.Foundations.Structure
open import Cubical.Data.Nat
open import Cubical.Data.List hiding ([_])
open import Cubical.Data.FinSet
open import Cubical.Data.FinSet.Constructors
open import Cubical.Data.SumFin
open import Cubical.Data.Empty as Empty
open import Cubical.Data.Sigma
open import Cubical.Data.Sum as Sum
open import Cubical.Data.Unit
open import Cubical.Data.W.Indexed
open import Cubical.Functions.FunExtEquiv

open import Cubical.Categories.Category
open import Cubical.Categories.Limits.Terminal
open import Cubical.Categories.Limits.Terminal.More
open import Cubical.Categories.Functor
open import Cubical.Categories.Instances.Sets
open import Cubical.Categories.Presheaf
open import Cubical.Categories.Presheaf.Constructions
open import Cubical.Categories.Presheaf.Representable
open import Cubical.Categories.Bifunctor.Redundant

open import Cubical.Categories.Displayed.Base
open import Cubical.Categories.Displayed.Functor
open import Cubical.Categories.Displayed.Section.Base
open import Cubical.Categories.Displayed.Instances.Sets.Base
open import Cubical.Categories.Displayed.Presheaf
open import Cubical.Categories.Displayed.Presheaf.Constructions
open import Cubical.Categories.Displayed.Limits.Terminal


variable
  ℓ ℓ' ℓ'' ℓ''' ℓC ℓC' : Level

open Category
open Functor
open Functorᴰ
open UniversalElement
open UniversalElementᴰ

module _ (BaseTy : Type ℓ) (isSetBaseTy : isSet BaseTy) where
  data Ty : Type ℓ where
    iBaseTy : BaseTy → Ty
    _⇒ₑ_ : Ty → Ty → Ty
  data Ctx : Type ℓ where
    1ₑ : Ctx
    _×ₑ_ : Ctx → Ty → Ctx

  -- todo: pick actually sensible numbers for these
  infixl 49 _×ₑ_
  infixr 50 _⇒ₑ_
  private
    variable
      A B C : Ty
      Γ Δ Θ : Ctx

  module _ (Gen : hSet ℓ') (dom : ⟨ Gen ⟩ → Ctx) (cod : ⟨ Gen ⟩ → Ty) where
    data Substitution : Ctx → Ctx → Type (ℓ-max ℓ ℓ')
    data Tm : Ctx → Ty → Type (ℓ-max ℓ ℓ')
    private
      variable
        γ δ θ : Substitution Δ Γ
        M N : Tm Γ A
    π₂ₑ' : Tm (Γ ×ₑ A) A
    _[_]' : Tm Γ A → Substitution Δ Γ → Tm Δ A
    
    data Substitution where
      idₑ : Substitution Γ Γ
      _⋆ₑ_ : Substitution Θ Δ → Substitution Δ Γ → Substitution Θ Γ
      ⋆IdLₑ : idₑ ⋆ₑ γ ≡ γ
      ⋆IdRₑ : γ ⋆ₑ idₑ ≡ γ
      ⋆Assocₑ : (γ ⋆ₑ δ) ⋆ₑ θ ≡ γ ⋆ₑ (δ ⋆ₑ θ)
      !ₑ : Substitution Γ 1ₑ
      1ηₑ : γ ≡ !ₑ
      _,ₑ_ : Substitution Δ Γ → Tm Δ A → Substitution Δ (Γ ×ₑ A)
      π₁ₑ : Substitution (Γ ×ₑ A) Γ
      ×β₁ₑ : (γ ,ₑ M) ⋆ₑ π₁ₑ ≡ γ
      ×ηₑ : γ ≡ ((γ ⋆ₑ π₁ₑ) ,ₑ (π₂ₑ' [ γ ]'))
      isSetSubst : isSet (Substitution Δ Γ)
    data Tm where
      iGen : (f : ⟨ Gen ⟩) → Tm (dom f) (cod f)
      _[_] : Tm Γ A → Substitution Δ Γ → Tm Δ A
      SubstId : M [ idₑ ] ≡ M
      SubstAssoc : M [ γ ⋆ₑ δ ] ≡ M [ δ ] [ γ ]
      π₂ₑ : Tm (Γ ×ₑ A) A
      ×β₂ₑ : π₂ₑ [ γ ,ₑ M ] ≡ M

      λₑ : Tm (Γ ×ₑ A) B → Tm Γ (A ⇒ₑ B)
      app : Tm (1ₑ ×ₑ A ⇒ₑ B ×ₑ A) B
      ⇒βₑ : app [ (!ₑ ,ₑ λₑ M) ,ₑ N ] ≡ M [ idₑ ,ₑ N ]
      ⇒ηₑ : M ≡ λₑ (app [ (!ₑ ,ₑ (M [ π₁ₑ ])) ,ₑ π₂ₑ ])

      isSetTm : isSet (Tm Γ A)
    π₂ₑ' = π₂ₑ
    _[_]' = _[_]
