{-

  The syntax of simply typed terms generated by base types and
  function symbols, along with its universal property as the initial
  simple category with families.

-}
{- TODO: cleanup universe levels -}
{- TODO: is FinOrd actually helpful here? -}

{-# OPTIONS --safe #-}
module Syntax.FreeSCwF where

open import Cubical.Foundations.Prelude
open import Cubical.Foundations.Equiv
open import Cubical.Foundations.HLevels
open import Cubical.Foundations.Structure

open import Cubical.Data.Sigma
open import Cubical.Categories.Category
open import Cubical.Categories.Limits.Terminal
open import Cubical.Categories.Limits.Terminal.More
open import Cubical.Categories.Functor
open import Cubical.Categories.Instances.Sets
open import Cubical.Categories.Presheaf
open import Cubical.Categories.Presheaf.Constructions
open import Cubical.Categories.Presheaf.Representable
open import Cubical.Categories.Bifunctor.Redundant

open import Cubical.Categories.Displayed.Base
import Cubical.Categories.Displayed.Reasoning as Reasoning
open import Cubical.Categories.Displayed.Functor
open import Cubical.Categories.Displayed.Section.Base
open import Cubical.Categories.Displayed.Instances.Sets.Base
open import Cubical.Categories.Displayed.Presheaf
open import Cubical.Categories.Displayed.Presheaf.Constructions
open import Cubical.Categories.Displayed.Limits.Terminal

open import Syntax.SimpleCategoryWithFamilies as SCWF

variable
  ℓ ℓ' ℓ'' ℓ''' ℓᴰ ℓᴰ' ℓᴰ'' ℓᴰ''' : Level

open Category
open Functor
open Functorᴰ
open UniversalElement
open UniversalElementᴰ

{-
  Here are some notions of context that we considered
  1. Σ[ Var ∈ FinSet ] ⟨ Var ⟩ → BaseTy
  2. Σ[ Var ∈ FinOrd ] ⟨ Var ⟩ → BaseTy
  3. Σ[ len ∈ ℕ ] Fin n → BaseTy
  4. List BaseTy

  1) is actually not equivalent to the rest, so we don't use it.
  2 and 3 are very similar but 3 has a better universe level
  2 and 3 are a bit annoying when actually doing the universal property.

  4 seems the simplest for the purpose of doing the universal property.

  Given 4 there are several ways to define substitution:
  1. Functional
  2. List
  3. freely generated
-}
module _ (BaseTy : Type ℓ) (isSetBaseTy : isSet BaseTy) where
  data Ctx : Type ℓ where
    1ₑ : Ctx
    _×ₑ_ : Ctx → BaseTy → Ctx

  private
    variable
      A B C : BaseTy
      Γ Δ Θ : Ctx

  module _ (Gen : hSet ℓ') (dom : ⟨ Gen ⟩ → Ctx) (cod : ⟨ Gen ⟩ → BaseTy) where
    data Substitution : Ctx → Ctx → Type (ℓ-max ℓ ℓ')
    data Tm : Ctx → BaseTy → Type (ℓ-max ℓ ℓ')
    private
      variable
        γ δ θ : Substitution Δ Γ
        M N : Tm Γ A
    π₂ₑ' : Tm (Γ ×ₑ A) A
    _[_]' : Tm Γ A → Substitution Δ Γ → Tm Δ A
    
    data Substitution where
      idₑ : Substitution Γ Γ
      _⋆ₑ_ : Substitution Θ Δ → Substitution Δ Γ → Substitution Θ Γ
      ⋆IdLₑ : idₑ ⋆ₑ γ ≡ γ
      ⋆IdRₑ : γ ⋆ₑ idₑ ≡ γ
      ⋆Assocₑ : (γ ⋆ₑ δ) ⋆ₑ θ ≡ γ ⋆ₑ (δ ⋆ₑ θ)
      !ₑ : Substitution Γ 1ₑ
      1ηₑ : γ ≡ !ₑ
      _,ₑ_ : Substitution Δ Γ → Tm Δ A → Substitution Δ (Γ ×ₑ A)
      π₁ₑ : Substitution (Γ ×ₑ A) Γ
      ×β₁ₑ : (γ ,ₑ M) ⋆ₑ π₁ₑ ≡ γ
      ×ηₑ : γ ≡ ((γ ⋆ₑ π₁ₑ) ,ₑ (π₂ₑ' [ γ ]'))
      isSetSubst : isSet (Substitution Δ Γ)
    data Tm where
      iGen : (f : ⟨ Gen ⟩) → Tm (dom f) (cod f)
      _[_] : Tm Γ A → Substitution Δ Γ → Tm Δ A
      SubstId : M [ idₑ ] ≡ M
      SubstAssoc : M [ γ ⋆ₑ δ ] ≡ M [ δ ] [ γ ]
      π₂ₑ : Tm (Γ ×ₑ A) A
      ×β₂ₑ : π₂ₑ [ γ ,ₑ M ] ≡ M
      isSetTm : isSet (Tm Γ A)
    π₂ₑ' = π₂ₑ
    _[_]' = _[_]

    CTX : Category ℓ (ℓ-max ℓ ℓ')
    CTX .ob = Ctx
    CTX .Hom[_,_] = Substitution
    CTX .id = idₑ
    CTX ._⋆_ = _⋆ₑ_
    CTX .⋆IdL = λ f → ⋆IdLₑ
    CTX .⋆IdR = λ f → ⋆IdRₑ
    CTX .⋆Assoc = λ f g h → ⋆Assocₑ
    CTX .isSetHom = isSetSubst

    TM : ∀ (A : BaseTy) → Presheaf CTX (ℓ-max ℓ ℓ')
    TM A .F-ob Γ .fst = Tm Γ A
    TM A .F-ob Γ .snd = isSetTm
    TM A .F-hom γ M = M [ γ ]
    TM A .F-id = funExt λ M → SubstId
    TM A .F-seq γ δ = funExt λ M → SubstAssoc

    terminalCtx : Terminal' CTX
    terminalCtx = terminalToUniversalElement T where
      T : Terminal CTX
      T .fst = 1ₑ
      T .snd Γ .fst = !ₑ
      T .snd Γ .snd = λ γ → sym 1ηₑ
    
    comprehensionSpec : ∀ (Γ : Ctx) (A : BaseTy)
      → Presheaf CTX (ℓ-max ℓ ℓ')
    comprehensionSpec Γ A = ProdWith (TM A) ⟅ Γ ⟆

    comprehension : ∀ Γ A → UniversalElement CTX (comprehensionSpec Γ A)
    comprehension Γ A .vertex = Γ ×ₑ A
    comprehension Γ A .element .fst = π₁ₑ
    comprehension Γ A .element .snd = π₂ₑ
    comprehension Γ A .universal Δ .equiv-proof (γ , M) .fst .fst = γ ,ₑ M
    comprehension Γ A .universal Δ .equiv-proof (γ , M) .fst .snd =
      ΣPathP (×β₁ₑ , ×β₂ₑ)
    comprehension Γ A .universal Δ .equiv-proof (γ , M) .snd (γ,M' , commutes) =
      ΣPathPProp (λ _ → comprehensionSpec Γ A .F-ob Δ .snd _ _)
        (sym (×ηₑ ∙ cong₂ _,ₑ_ (cong fst commutes) (cong snd commutes)))

    |FreeSCWF| : SimpleCategoryWithFamilies ℓ (ℓ-max ℓ ℓ') ℓ (ℓ-max ℓ ℓ')
    |FreeSCWF| .fst = CTX
    |FreeSCWF| .snd .fst = BaseTy
    |FreeSCWF| .snd .snd .fst = TM
    |FreeSCWF| .snd .snd .snd .fst = terminalCtx
    |FreeSCWF| .snd .snd .snd .snd = comprehension

    -- Universal property/fundamental lemma of free SCwF:
    -- any displayed SCwF over the syntax, with an interpretation of
    -- the generators extends to a section
    module _ (CTᴰ : SCWFᴰ |FreeSCWF| ℓᴰ ℓᴰ' ℓᴰ'' ℓᴰ''') where
      private
        CTXᴰ = CTᴰ .fst
        module CTXᴰ = Categoryᴰ CTXᴰ
        module R = Reasoning CTXᴰ
        Tyᴰ = CTᴰ .snd .fst
        TMᴰ = CTᴰ .snd .snd .fst
        terminalᴰ = CTᴰ .snd .snd .snd .fst
        comprehensionᴰ = CTᴰ .snd .snd .snd .snd

        Tmᴰ : ∀ {Γ}{A}(M : Tm Γ A)(Γᴰ : CTXᴰ.ob[ Γ ])(Aᴰ : Tyᴰ A) → Type _
        Tmᴰ M Γᴰ Aᴰ = TMᴰ Aᴰ .F-obᴰ Γᴰ M .fst 
        reindTm : ∀ {Γ A}{M M' : Tm Γ A}{Γᴰ Aᴰ} → M ≡ M' → Tmᴰ M Γᴰ Aᴰ → Tmᴰ M' Γᴰ Aᴰ
        reindTm = subst λ M → Tmᴰ M _ _

      module _ (⟦_⟧ty : ∀ A → Tyᴰ A) where
        ⟦_⟧ctx : ∀ Γ → CTXᴰ.ob[ Γ ]
        ⟦ 1ₑ ⟧ctx = terminalᴰ .vertexᴰ
        ⟦ Γ ×ₑ A ⟧ctx = comprehensionᴰ ⟦ Γ ⟧ctx ⟦ A ⟧ty .vertexᴰ
        module _ (⟦_⟧gen : ∀ f → Tmᴰ (iGen f) ⟦ dom f ⟧ctx ⟦ cod f ⟧ty) where
          ⟦_⟧subst : ∀ (γ : Substitution Δ Γ) → CTXᴰ.Hom[ γ ][ ⟦ Δ ⟧ctx , ⟦ Γ ⟧ctx ]
          ⟦_⟧tm : ∀ (M : Tm Γ A) → Tmᴰ M ⟦ Γ ⟧ctx ⟦ A ⟧ty

          ⟦ idₑ ⟧subst = CTXᴰ.idᴰ
          ⟦ δ ⋆ₑ γ ⟧subst = ⟦ δ ⟧subst CTXᴰ.⋆ᴰ ⟦ γ ⟧subst
          ⟦ ⋆IdLₑ {γ = γ} i ⟧subst = CTXᴰ.⋆IdLᴰ ⟦ γ ⟧subst i
          ⟦ ⋆IdRₑ  {γ = γ} i ⟧subst = CTXᴰ.⋆IdRᴰ ⟦ γ ⟧subst i
          ⟦ ⋆Assocₑ {γ = γ}{δ = δ}{θ = θ} i ⟧subst =
            CTXᴰ.⋆Assocᴰ ⟦ γ ⟧subst ⟦ δ ⟧subst ⟦ θ ⟧subst i
          ⟦ !ₑ ⟧subst = terminalᴰ .universalᴰ .equiv-proof _ .fst .fst
          ⟦ 1ηₑ i ⟧subst = {!terminalᴰ .universalᴰ .equiv-proof _ .snd _!}
          ⟦ γ ,ₑ M ⟧subst = comprehensionᴰ _ _ .universalᴰ .equiv-proof (R.reind (sym ×β₁ₑ) ⟦ γ ⟧subst , reindTm (sym ×β₂ₑ) ⟦ M ⟧tm) .fst .fst
          ⟦ π₁ₑ ⟧subst = comprehensionᴰ _ _ .elementᴰ .fst
          ⟦ ×β₁ₑ i ⟧subst = {!!}
          ⟦ ×ηₑ i ⟧subst = {!!}
          ⟦ isSetSubst γ δ p q i j ⟧subst = {!!}

          ⟦ iGen f ⟧tm = ⟦ f ⟧gen
          ⟦ M [ γ ] ⟧tm = TMᴰ _ .F-homᴰ ⟦ γ ⟧subst M ⟦ M ⟧tm 
          ⟦ SubstId {M = M} i ⟧tm = TMᴰ _ .F-idᴰ i M ⟦ M ⟧tm
          ⟦ SubstAssoc {M = M}{γ = γ}{δ = δ} i ⟧tm = TMᴰ _ .F-seqᴰ ⟦ δ ⟧subst ⟦ γ ⟧subst i M ⟦ M ⟧tm
          ⟦ π₂ₑ ⟧tm = comprehensionᴰ _ _ .elementᴰ .snd
          ⟦ ×β₂ₑ i ⟧tm = {!!}
          ⟦ isSetTm M M₁ x y i i₁ ⟧tm = {!!}


          iCTX : GlobalSection CTXᴰ
          iCTX .Section.F-obᴰ = ⟦_⟧ctx
          iCTX .Section.F-homᴰ = ⟦_⟧subst
          iCTX .Section.F-idᴰ = refl
          iCTX .Section.F-seqᴰ _ _ = refl

          iTm : ∀ A → PshSection CTXᴰ (TMᴰ ⟦ A ⟧ty) iCTX
          iTm A .PshSection.F-hom = ⟦_⟧tm
          iTm A .PshSection.F-nat _ _ = refl

          elim : SCWF.Section |FreeSCWF| CTᴰ
          elim .fst = iCTX
          elim .snd .fst = ⟦_⟧ty
          elim .snd .snd .fst = iTm _
          elim .snd .snd .snd .fst = refl
          elim .snd .snd .snd .snd Γ A .fst = refl
          elim .snd .snd .snd .snd Γ A .snd .fst = refl
          elim .snd .snd .snd .snd Γ A .snd .snd = refl
