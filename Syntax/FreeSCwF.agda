{-

  The syntax of simply typed terms generated by base types and
  function symbols, along with its universal property as the initial
  simple category with families.

-}
{- TODO: cleanup universe levels -}
{- TODO: is FinOrd actually helpful here? -}

{-# OPTIONS --safe #-}
module Syntax.FreeSCwF where

open import Cubical.Foundations.Prelude
open import Cubical.Foundations.Equiv
open import Cubical.Foundations.HLevels
open import Cubical.Foundations.Structure
open import Cubical.Data.Nat
open import Cubical.Data.List hiding ([_])
open import Cubical.Data.FinSet
open import Cubical.Data.FinSet.Constructors
open import Cubical.Data.SumFin
open import Cubical.Data.Empty as Empty
open import Cubical.Data.Sigma
open import Cubical.Data.Sum as Sum
open import Cubical.Data.Unit
open import Cubical.Data.W.Indexed
open import Cubical.Functions.FunExtEquiv

open import Cubical.Categories.Category
open import Cubical.Categories.Limits.Terminal
open import Cubical.Categories.Limits.Terminal.More
open import Cubical.Categories.Functor
open import Cubical.Categories.Instances.Sets
open import Cubical.Categories.Presheaf
open import Cubical.Categories.Presheaf.Constructions
open import Cubical.Categories.Presheaf.Representable
open import Cubical.Categories.Bifunctor.Redundant

open import Cubical.Categories.Displayed.Base
open import Cubical.Categories.Displayed.Functor
open import Cubical.Categories.Displayed.Section.Base
open import Cubical.Categories.Displayed.Instances.Sets.Base
open import Cubical.Categories.Displayed.Presheaf
open import Cubical.Categories.Displayed.Presheaf.Constructions
open import Cubical.Categories.Displayed.Limits.Terminal


variable
  ℓ ℓ' ℓ'' ℓ''' ℓC ℓC' : Level

open Category
open Functor
open Functorᴰ
open UniversalElement
open UniversalElementᴰ

FinOrd : ∀ ℓ → Type (ℓ-suc ℓ)
FinOrd ℓ = TypeWithStr ℓ isFinOrd

isFinOrdUnit* : ∀ {ℓ} → isFinOrd (Unit* {ℓ})
isFinOrdUnit* .fst = 1
isFinOrdUnit* .snd .fst = λ _ → fzero
isFinOrdUnit* .snd .snd .equiv-proof = Sum.elim (λ _ → (tt* , refl) , λ y →
  ΣPathPProp (λ _ → isSetFin _ _) refl) Empty.elim


{-
  Here are some notions of context that we considered
  1. Σ[ Var ∈ FinSet ] ⟨ Var ⟩ → BaseTy
  2. Σ[ Var ∈ FinOrd ] ⟨ Var ⟩ → BaseTy
  3. Σ[ len ∈ ℕ ] Fin n → BaseTy
  4. List BaseTy

  1) is actually not equivalent to the rest, so we don't use it.
  2 and 3 are very similar but 3 has a better universe level
  2 and 3 are a bit annoying when actually doing the universal property.

  4 seems the simplest for the purpose of doing the universal property.

  Given 4 there are several ways to define substitution:
  1. Functional
  2. List
  3. freely generated
-}
module _ (BaseTy : Type ℓ) (isSetBaseTy : isSet BaseTy) where
  data Ctx : Type ℓ where
    1ₑ : Ctx
    _×ₑ_ : Ctx → BaseTy → Ctx

  private
    variable
      A B C : BaseTy
      Γ Δ Θ : Ctx

  module _ (Gen : hSet ℓ') (dom : ⟨ Gen ⟩ → Ctx) (cod : ⟨ Gen ⟩ → BaseTy) where
    data Substitution : Ctx → Ctx → Type (ℓ-max ℓ ℓ')
    data Tm : Ctx → BaseTy → Type (ℓ-max ℓ ℓ')
    private
      variable
        γ δ θ : Substitution Δ Γ
        M N : Tm Γ A
    π₂ₑ' : Tm (Γ ×ₑ A) A
    _[_]' : Tm Γ A → Substitution Δ Γ → Tm Δ A
    
    data Substitution where
      idₑ : Substitution Γ Γ
      _⋆ₑ_ : Substitution Θ Δ → Substitution Δ Γ → Substitution Θ Γ
      ⋆IdLₑ : idₑ ⋆ₑ γ ≡ γ
      ⋆IdRₑ : γ ⋆ₑ idₑ ≡ γ
      ⋆Assocₑ : (γ ⋆ₑ δ) ⋆ₑ θ ≡ γ ⋆ₑ (δ ⋆ₑ θ)
      !ₑ : Substitution Γ 1ₑ
      1ηₑ : γ ≡ !ₑ
      _,ₑ_ : Substitution Δ Γ → Tm Δ A → Substitution Δ (Γ ×ₑ A)
      π₁ₑ : Substitution (Γ ×ₑ A) Γ
      ×β₁ₑ : (γ ,ₑ M) ⋆ₑ π₁ₑ ≡ γ
      ×ηₑ : γ ≡ ((γ ⋆ₑ π₁ₑ) ,ₑ (π₂ₑ' [ γ ]'))
      isSetSubst : isSet (Substitution Δ Γ)
    data Tm where
      iGen : (f : ⟨ Gen ⟩) → Tm (dom f) (cod f)
      _[_] : Tm Γ A → Substitution Δ Γ → Tm Δ A
      SubstId : M [ idₑ ] ≡ M
      SubstAssoc : M [ γ ⋆ₑ δ ] ≡ M [ δ ] [ γ ]
      π₂ₑ : Tm (Γ ×ₑ A) A
      ×β₂ₑ : π₂ₑ [ γ ,ₑ M ] ≡ M
      isSetTm : isSet (Tm Γ A)
    π₂ₑ' = π₂ₑ
    _[_]' = _[_]

    CTX : Category ℓ (ℓ-max ℓ ℓ')
    CTX .ob = Ctx
    CTX .Hom[_,_] = Substitution
    CTX .id = idₑ
    CTX ._⋆_ = _⋆ₑ_
    CTX .⋆IdL = λ f → ⋆IdLₑ
    CTX .⋆IdR = λ f → ⋆IdRₑ
    CTX .⋆Assoc = λ f g h → ⋆Assocₑ
    CTX .isSetHom = isSetSubst

    TM : ∀ (A : BaseTy) → Presheaf CTX (ℓ-max ℓ ℓ')
    TM A .F-ob Γ .fst = Tm Γ A
    TM A .F-ob Γ .snd = isSetTm
    TM A .F-hom γ M = M [ γ ]
    TM A .F-id = funExt λ M → SubstId
    TM A .F-seq γ δ = funExt λ M → SubstAssoc

    terminalCtx : Terminal' CTX
    terminalCtx = terminalToUniversalElement T where
      T : Terminal CTX
      T .fst = 1ₑ
      T .snd Γ .fst = !ₑ
      T .snd Γ .snd = λ γ → sym 1ηₑ
    
    comprehensionSpec : ∀ (Γ : Ctx) (A : BaseTy)
      → Presheaf CTX (ℓ-max ℓ ℓ')
    comprehensionSpec Γ A = PshProd ⟅ (CTX [-, Γ ]) , TM A ⟆b

    comprehension : ∀ Γ A → UniversalElement CTX (comprehensionSpec Γ A)
    comprehension Γ A .vertex = Γ ×ₑ A
    comprehension Γ A .element .fst = π₁ₑ
    comprehension Γ A .element .snd = π₂ₑ
    comprehension Γ A .universal Δ .equiv-proof (γ , M) .fst .fst = γ ,ₑ M
    comprehension Γ A .universal Δ .equiv-proof (γ , M) .fst .snd =
      ΣPathP (×β₁ₑ , ×β₂ₑ)
    comprehension Γ A .universal Δ .equiv-proof (γ , M) .snd (γ,M' , commutes) =
      ΣPathPProp (λ _ → comprehensionSpec Γ A .F-ob Δ .snd _ _)
        (sym (×ηₑ ∙ cong₂ _,ₑ_ (cong fst commutes) (cong snd commutes)))

    -- Universal property/fundamental lemma of free SCwF:
    -- any displayed SCwF over the syntax, with an interpretation of
    -- the generators extends to a section

    -- we have a notion of "relation over contexts and preservation of relations by substitutions"
    module _ (CTXᴰ : Categoryᴰ CTX ℓC ℓC')
             -- a notion of "relation over types"
             (Tyᴰ : BaseTy → Type ℓ'')
             -- a notion of "preservation of relations by terms" that has an action of substitution
             (TMᴰ : ∀ {A} (Aᴰ : Tyᴰ A) → Presheafᴰ CTXᴰ (TM A) ℓ''')
      where
      private
        module CTXᴰ = Categoryᴰ CTXᴰ
      comprehensionSpecᴰ : ∀ {Γ}{A}(Γᴰ : CTXᴰ.ob[ Γ ])(Aᴰ : Tyᴰ A)
        → Presheafᴰ CTXᴰ (comprehensionSpec Γ A) _
      comprehensionSpecᴰ Γᴰ Aᴰ = PshProdᴰ (CTXᴰ [-][-, Γᴰ ]) (TMᴰ Aᴰ)

      -- Now that we have appropriate "notions of relation" and "notions of preservation of relation"
      -- We need to start actually constructing the relations and proving the terms preserve them.
      module _
        -- first we need an empty relation over the empty context
        (terminalᴰ : LiftedTerminal CTXᴰ terminalCtx)
        -- next we need a context extension relation over context extension
        (comprehensionᴰ : ∀ {Γ}{A} Γᴰ Aᴰ
          → UniversalElementᴰ CTXᴰ
                              (comprehensionSpecᴰ Γᴰ Aᴰ)
                              (comprehension Γ A))
        -- and an interpretation of each base type as a relation
        (⟦_⟧ty : ∀ A → Tyᴰ A)
        where
        ⟦_⟧ctx : ∀ Γ → CTXᴰ.ob[ Γ ]
        ⟦ 1ₑ ⟧ctx = terminalᴰ .vertexᴰ
        ⟦ Γ ×ₑ A ⟧ctx = comprehensionᴰ ⟦ Γ ⟧ctx ⟦ A ⟧ty .vertexᴰ

        Tmᴰ : ∀ {Γ}{A}(M : Tm Γ A)(Γᴰ : CTXᴰ.ob[ Γ ])(Aᴰ : Tyᴰ A) → Type _
        Tmᴰ M Γᴰ Aᴰ = TMᴰ Aᴰ .F-obᴰ Γᴰ M .fst 

        module _ (⟦_⟧gen : ∀ (f : ⟨ Gen ⟩) → Tmᴰ (iGen f) ⟦ dom f ⟧ctx ⟦ cod f ⟧ty) where
          ⟦_⟧subst : ∀ (γ : Substitution Δ Γ) → CTXᴰ.Hom[ γ ][ ⟦ Δ ⟧ctx , ⟦ Γ ⟧ctx ]
          ⟦_⟧tm : ∀ (M : Tm Γ A) → Tmᴰ M ⟦ Γ ⟧ctx ⟦ A ⟧ty

          ⟦ idₑ ⟧subst = CTXᴰ.idᴰ
          ⟦ δ ⋆ₑ γ ⟧subst = ⟦ δ ⟧subst CTXᴰ.⋆ᴰ ⟦ γ ⟧subst
          ⟦ ⋆IdLₑ i ⟧subst = {!!}
          ⟦ ⋆IdRₑ i ⟧subst = {!!}
          ⟦ ⋆Assocₑ i ⟧subst = {!!}
          ⟦ !ₑ ⟧subst = {!!}
          ⟦ 1ηₑ i ⟧subst = {!!}
          ⟦ γ ,ₑ M ⟧subst = comprehensionᴰ _ _ .universalᴰ .equiv-proof ({!!} , {!!}) .fst .fst
          ⟦ π₁ₑ ⟧subst = comprehensionᴰ _ _ .elementᴰ .fst
          ⟦ ×β₁ₑ i ⟧subst = {!!}
          ⟦ ×ηₑ i ⟧subst = {!!}
          ⟦ isSetSubst γ δ p q i j ⟧subst = {!!}

          ⟦ iGen f ⟧tm = ⟦ f ⟧gen
          ⟦ M [ γ ] ⟧tm = TMᴰ _ .F-homᴰ ⟦ γ ⟧subst M ⟦ M ⟧tm 
          ⟦ SubstId i ⟧tm = {!!}
          ⟦ SubstAssoc i ⟧tm = {!!}
          ⟦ π₂ₑ ⟧tm = comprehensionᴰ _ _ .elementᴰ .snd
          ⟦ ×β₂ₑ i ⟧tm = {!!}
          ⟦ isSetTm M M₁ x y i i₁ ⟧tm = {!!}


          iCTX : GlobalSection CTXᴰ
          iCTX = {!!}
