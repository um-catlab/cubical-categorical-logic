{-

  The syntax of simply typed terms generated by base types and
  function symbols, along with its universal property as the initial
  simple category with families.

-}
{- TODO: cleanup universe levels -}
{- TODO: is FinOrd actually helpful here? -}

{-# OPTIONS --safe #-}
module Syntax.STLC where

open import Cubical.Foundations.Prelude
open import Cubical.Foundations.Equiv
open import Cubical.Foundations.HLevels
open import Cubical.Foundations.Structure
open import Cubical.Data.Nat
open import Cubical.Data.List hiding ([_])
open import Cubical.Data.FinSet
open import Cubical.Data.FinSet.Constructors
open import Cubical.Data.SumFin
open import Cubical.Data.Empty as Empty
open import Cubical.Data.Sigma
open import Cubical.Data.Sum as Sum
open import Cubical.Data.Unit
open import Cubical.Data.W.Indexed
open import Cubical.Functions.FunExtEquiv

open import Cubical.Categories.Category
open import Cubical.Categories.Limits.Terminal
open import Cubical.Categories.Limits.Terminal.More
open import Cubical.Categories.Functor
open import Cubical.Categories.Instances.Sets
open import Cubical.Categories.Presheaf
open import Cubical.Categories.Presheaf.Constructions
open import Cubical.Categories.Presheaf.Representable
open import Cubical.Categories.Bifunctor.Redundant

open import Cubical.Categories.Displayed.Base
open import Cubical.Categories.Displayed.Instances.Sets.Base
open import Cubical.Categories.Displayed.Presheaf
open import Cubical.Categories.Displayed.Presheaf.Constructions
open import Cubical.Categories.Displayed.Limits.Terminal


variable
  ℓ ℓ' ℓ'' ℓ''' ℓC ℓC' : Level

open Category
open Functor
open UniversalElement
open UniversalElementᴰ

FinOrd : ∀ ℓ → Type (ℓ-suc ℓ)
FinOrd ℓ = TypeWithStr ℓ isFinOrd

isFinOrdUnit* : ∀ {ℓ} → isFinOrd (Unit* {ℓ})
isFinOrdUnit* .fst = 1
isFinOrdUnit* .snd .fst = λ _ → fzero
isFinOrdUnit* .snd .snd .equiv-proof = Sum.elim (λ _ → (tt* , refl) , λ y →
  ΣPathPProp (λ _ → isSetFin _ _) refl) Empty.elim


{-
  Here are some notions of context that we considered
  1. Σ[ Var ∈ FinSet ] ⟨ Var ⟩ → BaseTy
  2. Σ[ Var ∈ FinOrd ] ⟨ Var ⟩ → BaseTy
  3. Σ[ len ∈ ℕ ] Fin n → BaseTy
  4. List BaseTy

  1) is actually not equivalent to the rest, so we don't use it.
  2 and 3 are very similar but 3 has a better universe level
  2 and 3 are a bit annoying when actually doing the universal property.

  4 seems the simplest for the purpose of doing the universal property.

  Given 4 there are several ways to define substitution:
  1. Functional
  2. List
  3. freely generated
-}
module _ (BaseTy : Type ℓ) (isSetBaseTy : isSet BaseTy) where
  Ctx : Type ℓ
  Ctx = List BaseTy

  module _ (Gen : hSet ℓ') (dom : ⟨ Gen ⟩ → Ctx) (cod : ⟨ Gen ⟩ → BaseTy) where
    data Substitution (Γ : Ctx) : Ctx → Type (ℓ-max ℓ ℓ')
    data Tm (Γ : Ctx) : BaseTy → Type (ℓ-max ℓ ℓ')
    data Var (A : BaseTy) : Ctx → Type (ℓ-max ℓ ℓ')

    data Substitution Γ where
      [] : Substitution Γ []
      _∷_ : ∀ {A Δ} → Tm Γ A → Substitution Γ Δ → Substitution Γ (A ∷ Δ)
    data Var A where
      zro : ∀ {Γ} → Var A (A ∷ Γ)
      suc : ∀ {Γ B} → Var A Γ → Var A (B ∷ Γ)
    data Tm Γ where
      var : ∀ {A} → Var A Γ → Tm Γ A
      gen : ∀ (f : ⟨ Gen ⟩) (γ : Substitution Γ (dom f)) → Tm Γ (cod f)

  --   _[_] : ∀ {Δ Γ A} (M : Tm Γ A) (γ : Substitution Δ Γ) → Tm Δ A
  --   _⋆s_ : ∀ {Δ Γ Θ} (δ : Substitution Θ Δ) (γ : Substitution Δ Γ)
  --     → Substitution Θ Γ
  --   var x [ γ ] = γ x
  --   gen f θ [ γ ] = gen f (γ ⋆s θ)

  --   (δ ⋆s γ) x = γ x [ δ ]

  -- --   substId : ∀ {Γ A} (M : Tm Γ A) → M [ var ] ≡ M
  --   substId (var x) = refl
  --   substId (gen f γ) = cong (gen f) (funExt λ x → substId (γ x))

  --   substAssoc : ∀ {Θ Δ Γ A}
  --     (δ : Substitution Θ Δ) (γ : Substitution Δ Γ) (M : Tm Γ A)
  --     → (M [ δ ⋆s γ ]) ≡ M [ γ ] [ δ ]
  --   substAssoc δ γ (var x) = refl
  --   substAssoc δ γ (gen f γ') =
  --     cong (gen f) (funExt λ x → substAssoc _ _ (γ' x))

  --   isSetTm : ∀ {Γ}{A} → isSet (Tm Γ A)
  --   isSetTm {Γ}{A} =
  --     isSetRetract {B = Tree A} encode decode retr isSetTree where
  --     Tree = IW {X = BaseTy}
  --       (λ A → fiber (Γ .snd) A ⊎ fiber cod A)
  --       (λ _ → Sum.rec (λ _ → ⊥) λ f → Var (dom (f .fst)))
  --       (λ A → Sum.elim (λ _ → Empty.rec) λ f → (dom (f .fst)) .snd)
  --     encode : ∀ {A} → Tm Γ A → Tree A
  --     encode (var x) = node (inl (x , refl)) Empty.elim
  --     encode (gen f γ) = node (inr (f , refl)) (λ x → encode (γ x))

  --     decode : ∀ {A} → Tree A → Tm Γ A
  --     decode (node (inl x) subtree) =
  --       subst (λ A → Tm Γ A) (x .snd) (var (x .fst))
  --     decode (node (inr f) subtree) =
  --       subst (λ A → Tm Γ A) (f .snd) (gen (f .fst) (λ x → decode (subtree x)))

  --     retr : ∀ {A} (M : Tm Γ A) → decode (encode M) ≡ M
  --     retr (var x) = transportRefl (var x)
  --     retr (gen f γ) = transportRefl (gen f (λ x → decode (encode (γ x))))
  --       ∙ cong (gen f) (funExt λ x → retr (γ x))

  --     isSetTree : ∀ {A} → isSet (Tree A)
  --     isSetTree = isOfHLevelSuc-IW 1 (λ A → isSet⊎
  --       (isSetΣ (isSetVar Γ)  λ x → isProp→isSet (isSetBaseTy _ _))
  --       (isSetΣ (Gen .snd) (λ f → isProp→isSet (isSetBaseTy _ _))))
  --       _

  --   -- The following three things constitute a "simple category with families".
  --   -- The universal property of the syntax is that it is the initial such thing
  --   Subst : Category _ _
  --   Subst .ob = Ctx
  --   Subst .Hom[_,_] Δ Γ = Substitution Δ Γ
  --   Subst .id = var
  --   Subst ._⋆_ = _⋆s_
  --   Subst .⋆IdL γ = funExt λ x → substId (γ x)
  --   Subst .⋆IdR γ = refl
  --   Subst .⋆Assoc f g h = funExt λ x → (substAssoc f g (h x))
  --   Subst .isSetHom {x = Γ} = isSetΠ (λ x → isSetTm)

  --   TM : ∀ (A : BaseTy) → Presheaf Subst (ℓ-max ℓ ℓ')
  --   TM A .F-ob Γ .fst = Tm Γ A
  --   TM A .F-ob Γ .snd = isSetTm
  --   TM A .F-hom γ M = M [ γ ]
  --   TM A .F-id = funExt substId
  --   TM A .F-seq f g = funExt (substAssoc g f)

  --   iGen : ∀ (f : ⟨ Gen ⟩) → Tm (dom f) (cod f)
  --   iGen f = gen f var

  --   terminalCtx : Terminal Subst
  --   terminalCtx .fst .fst = 0
  --   terminalCtx .fst .snd = Empty.rec
  --   terminalCtx .snd Γ' .fst = Empty.elim
  --   terminalCtx .snd Γ' .snd foo = funExt Empty.elim

  --   comprehensionSpec : ∀ (Γ : Ctx) (A : BaseTy)
  --     → Presheaf Subst (ℓ-max ℓ ℓ')
  --   comprehensionSpec Γ A = PshProd ⟅ (Subst [-, Γ ]) , TM A ⟆b

  --   comprehension : ∀ Γ A
  --     → UniversalElement Subst (comprehensionSpec Γ A)
  --   comprehension Γ A .vertex .fst = suc (Γ .fst)
  --   comprehension Γ A .vertex .snd = Sum.rec (λ _ → A) (Γ .snd)
  --   comprehension Γ A .element .fst x = var (inr x)
  --   comprehension Γ A .element .snd = var (inl _)
  --   comprehension Γ A .universal Δ .equiv-proof (γ , M) .fst .fst =
  --     Sum.elim (λ _ → M) γ
  --   comprehension Γ A .universal Δ .equiv-proof (γ , M) .fst .snd = refl
  --   comprehension Γ A .universal Δ .equiv-proof (γ , M) .snd (γ,M , commutes) =
  --     ΣPathPProp ((λ _ → isSetΣ (isSetHom Subst {x = Δ}{Γ}) (λ _ → (TM A ⟅ Δ ⟆) .snd) _ _))
  --     (funExt (Sum.elim ((λ _ → sym (cong snd commutes))) ((λ x → sym (funExt⁻ (cong fst commutes) x)))))

  --   -- Universal property/fundamental lemma of STLC:
  --   -- any displayed SCwF over the syntax, with an interpretation of
  --   -- the generators extends to a section

  --   -- we have a notion of "relation over contexts and preservation of relations by substitutions"
  --   module _ (Substᴰ : Categoryᴰ Subst ℓC ℓC')
  --            -- a notion of "relation over types"
  --            (Tyᴰ : BaseTy → Type ℓ'')
  --            -- a notion of "preservation of relations by terms" that has an action of substitution
  --            (TMᴰ : ∀ {A} (Aᴰ : Tyᴰ A) → Presheafᴰ Substᴰ (TM A) ℓ''')
  --     where
  --     private
  --       module Substᴰ = Categoryᴰ Substᴰ
  --     comprehensionSpecᴰ : ∀ {Γ}{A}(Γᴰ : Substᴰ.ob[ Γ ])(Aᴰ : Tyᴰ A)
  --       → Presheafᴰ Substᴰ (comprehensionSpec Γ A) _
  --     comprehensionSpecᴰ Γᴰ Aᴰ = PshProdᴰ (Substᴰ [-][-, Γᴰ ]) (TMᴰ Aᴰ)

  --     -- Now that we have appropriate "notions of relation" and "notions of preservation of relation"
  --     -- We need to start actually constructing the relations and proving the terms preserve them.
  --     module _
  --       -- first we need an empty relation over the empty context
  --       (terminalᴰ : LiftedTerminal Substᴰ (terminalToUniversalElement terminalCtx))
  --       -- next we need a context extension relation over context extension
  --       (comprehensionᴰ : ∀ {Γ}{A} Γᴰ Aᴰ
  --         → UniversalElementᴰ Substᴰ
  --                             (comprehensionSpecᴰ Γᴰ Aᴰ)
  --                             (comprehension Γ A))
  --       -- and an interpretation of each base type as a relation
  --       (iBaseTy : ∀ A → Tyᴰ A)
  --       where

  --       ⟦_⟧ctx : ∀ (Γ : Ctx) → Substᴰ.ob[ Γ ]
  --       ⟦ zero , foo ⟧ctx = {!terminalᴰ .vertexᴰ!}
  --       ⟦ suc n , tys ⟧ctx = {!!}
